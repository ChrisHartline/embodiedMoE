[
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify the exact line and error type. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. You can also wrap suspicious code in try-except blocks to catch and handle specific exceptions gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that can benefit from concurrency. Async programming allows other code to run while waiting for these operations to complete, improving overall performance. However, it's not beneficial for CPU-bound tasks and adds complexity, so only use it when you have genuine concurrency needs.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. However, in the worst case (when there are many hash collisions), it can degrade to O(n). Python's hash table implementation uses open addressing and dynamic resizing to minimize collisions and maintain good performance.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in async functions?",
    "answer": "Use try-except blocks around await expressions just like in synchronous code, but be aware that exceptions in background tasks won't propagate automatically. For fire-and-forget tasks created with asyncio.create_task(), you should either await the task or add a done callback to handle exceptions. Consider using asyncio.gather() with return_exceptions=True when coordinating multiple async operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions for variables and functions?",
    "answer": "Use snake_case for variables and functions (e.g., user_name, calculate_total). Class names should use PascalCase (e.g., UserAccount). Constants should be in UPPER_CASE (e.g., MAX_SIZE). Private attributes start with underscore (_private_var) and avoid names starting with double underscores unless you understand name mangling.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work with reference cycles?",
    "answer": "Python uses reference counting as the primary garbage collection mechanism, but this can't handle reference cycles. For cycles, Python employs a cyclic garbage collector that periodically runs and uses a mark-and-sweep algorithm to detect and clean up unreachable objects. You can control this behavior using the gc module, and weak references can help prevent cycles in the first place.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator compares values for equality by calling the __eq__ method, while 'is' compares object identity (whether two variables point to the same object in memory). Use '==' to check if two objects have the same value, and 'is' to check if they're literally the same object. Always use 'is' when comparing to None, True, or False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a custom iterator class in Python?",
    "answer": "Define a class with __iter__() and __next__() methods. The __iter__() method should return self, and __next__() should return the next item or raise StopIteration when done. You'll also typically need an __init__() method to set up initial state and track position. Alternatively, consider using generators with yield, which automatically create iterators and are often simpler.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are the performance implications of using asyncio.gather() vs asyncio.as_completed()?",
    "answer": "asyncio.gather() waits for all tasks to complete and returns results in the original order, making it suitable when you need all results together. asyncio.as_completed() yields tasks as they finish, allowing you to process results immediately and potentially start new work sooner. Use as_completed() when you want to handle results as they become available, and gather() when you need coordinated completion of all tasks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that changes frequently, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your code involves I/O operations like network requests, file reading, or database queries that would otherwise block execution. Async programming allows other code to run while waiting for these operations to complete, improving performance in I/O-bound applications. It's particularly useful for web scraping, API calls, or handling multiple concurrent connections in web servers.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and execution flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step-by-step, verify input data, and ensure your conditions and loops are working as expected. IDEs like PyCharm or VS Code also offer visual debugging tools with breakpoints.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have O(1) average time complexity because dictionaries are implemented as hash tables. In the worst case (with many hash collisions), it could degrade to O(n), but this is extremely rare in practice. This makes dictionaries excellent for fast key-based lookups, which is why they're preferred over lists when you need to frequently search for items.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using global variables in my Python code?",
    "answer": "Global variables make code harder to test, debug, and maintain because any function can modify them, creating unpredictable side effects. They also make it difficult to track where values are changed and can lead to naming conflicts in larger programs. Instead, pass variables as function parameters and return values, or use classes to encapsulate related data and behavior.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does the QuickSort algorithm work and what's its performance?",
    "answer": "QuickSort selects a 'pivot' element, partitions the array so smaller elements are on one side and larger on the other, then recursively sorts both sides. It has O(n log n) average time complexity but O(n\u00b2) worst case when the pivot is always the smallest/largest element. Despite the worst case, it's often faster than other O(n log n) algorithms in practice due to good cache performance and lower constant factors.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What happens when I await multiple async functions in Python?",
    "answer": "When you await multiple async functions sequentially, they run one after another, which doesn't provide concurrency benefits. To run them concurrently, use asyncio.gather() or asyncio.create_task() to start them simultaneously, then await the results. This allows all the async operations to run in parallel, significantly reducing total execution time for I/O-bound tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using 'if x % 2 == 0', then squares each even number with 'x**2'. The result is [0, 4, 16, 36, 64], representing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle race conditions when using asyncio in Python?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Event() to coordinate access to shared resources. Locks ensure only one coroutine accesses critical sections at a time, while semaphores limit concurrent access to a specific number. You can also use asyncio.Queue for safe communication between coroutines. Always acquire locks using 'async with lock:' syntax to ensure proper cleanup.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but inserts references to the objects found in the original, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy is slower but provides complete independence between the original and copy.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are ideal when you need to modify data, while tuples are better for fixed data that shouldn't change. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running slowly?",
    "answer": "Start by using Python's built-in profiler with 'python -m cProfile your_script.py' to identify bottlenecks. You can also use the 'time' module to measure specific function execution times, or tools like 'line_profiler' for line-by-line analysis. Look for nested loops, inefficient data structure usage, or unnecessary file I/O operations as common culprits.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file reading, or database queries that would otherwise block execution. It's particularly beneficial when you need to handle multiple concurrent operations without using threads. However, avoid async/await for CPU-intensive tasks as it won't provide performance benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: result = [x**2 for x in range(5) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 4. It iterates through range(5) [0,1,2,3,4], filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result will be [0, 4, 16] representing 0\u00b2, 2\u00b2, and 4\u00b2.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple native threads from executing Python bytecode simultaneously, effectively making Python threads cooperative rather than truly parallel for CPU-bound tasks. This means threading in Python is most beneficial for I/O-bound operations where threads can release the GIL while waiting. For CPU-intensive tasks requiring parallelism, use the multiprocessing module instead of threading.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. However, in the worst-case scenario (when many hash collisions occur), it can degrade to O(n). In practice, Python's hash table is well-optimized and you can expect constant-time lookups for most use cases.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than broad except clauses, and always handle exceptions at the appropriate level. Include finally blocks for cleanup code that must run regardless of exceptions. For example: try/except ValueError/finally is better than a bare except clause, and consider using 'with' statements for resource management.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await asyncio.gather()' and 'await asyncio.wait()'?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception immediately if any coroutine fails. asyncio.wait() provides more control, returning done and pending sets, and allows you to specify when to return (first completed, first exception, or all completed). Use gather() for simple concurrent execution and wait() when you need fine-grained control over completion handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using mutable default arguments in Python functions?",
    "answer": "Mutable default arguments (like lists or dictionaries) are evaluated only once when the function is defined, not each time it's called. This means the same object is shared across all function calls, leading to unexpected behavior where modifications persist between calls. Instead, use None as the default and create the mutable object inside the function: def func(items=None): if items is None: items = [].",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to check if an item exists in a large collection?",
    "answer": "Use a set for O(1) average-case lookup time, which is much faster than lists O(n) or tuples O(n). If you need to maintain order, consider using a dictionary with dummy values or Python 3.7+ ordered dictionaries. For very large datasets, you might also consider using data structures like bloom filters for approximate membership testing with minimal memory usage.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are good for collections that need to be modified, while tuples are perfect for data that shouldn't change, like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. You need to run async functions using asyncio.run() or within an event loop. This allows your program to handle other tasks while waiting for slow operations to complete, improving performance for concurrent operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "My Python code throws an IndexError. How do I debug this?",
    "answer": "IndexError means you're trying to access a list/string index that doesn't exist. Check the length of your sequence with len() and ensure your index is within range (0 to len-1). Use print statements or a debugger to check variable values before the error occurs. Consider using try/except blocks or conditional checks like 'if index < len(my_list):' to prevent the error.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations in Python have average O(1) time complexity for lookup, insertion, and deletion due to hash table implementation. However, in worst-case scenarios (many hash collisions), these can degrade to O(n). Iteration over all keys/values is O(n) where n is the number of items. This makes dictionaries excellent for fast lookups and caching scenarios.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How should I handle exceptions in Python code?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except:' clauses. Handle the most specific exceptions first, then more general ones. Always clean up resources using 'finally' blocks or context managers (with statements). Log exceptions appropriately and only catch exceptions you can meaningfully handle - let others propagate up the call stack.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value (equality), while 'is' checks if two variables reference the exact same object in memory (identity). Use '==' for comparing values and 'is' for comparing with None or checking object identity. For example, two lists with identical contents are == but not 'is' unless they're the same list object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search requires a sorted array and repeatedly divides the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n). Here's the key: maintain left and right pointers, calculate mid = (left + right) // 2, and update pointers based on comparison until left > right.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create one?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. They use the @decorator_name syntax above function definitions. To create one, write a function that takes another function as an argument, defines an inner wrapper function, and returns the wrapper. The wrapper can execute code before/after calling the original function, modify arguments, or change return values.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I avoid common performance issues in Python loops?",
    "answer": "Move invariant calculations outside loops, use list comprehensions instead of append() in loops when possible, and avoid repeated attribute lookups by storing them in local variables. Use built-in functions like map(), filter(), and sum() which are implemented in C. For large datasets, consider using generators to save memory and numpy for numerical operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between append() and extend() for Python lists?",
    "answer": "append() adds a single element to the end of a list, even if that element is itself a list. extend() adds each element from an iterable (like another list) individually to the end of the list. So list.append([1,2]) adds one element (a nested list), while list.extend([1,2]) adds two separate elements (1 and 2). Use append() for single items and extend() to merge lists.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or configuration settings. Tuples also use less memory and can be used as dictionary keys, unlike lists.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's throwing a NameError?",
    "answer": "A NameError occurs when Python can't find a variable or function name you're trying to use. Check for typos in variable names, ensure variables are defined before use, and verify correct indentation in your code. You can also use print statements or a debugger to trace where variables are defined and used in your program.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does async/await do in Python and when should I use it?",
    "answer": "Async/await enables asynchronous programming, allowing your program to handle other tasks while waiting for slow operations like file I/O or network requests. Use async/await when you have I/O-bound operations that would otherwise block your program. This is especially useful for web scraping, API calls, or handling multiple concurrent connections in web applications.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a simple implementation: `def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left+right)//2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid+1; else: right = mid-1; return -1`",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean code?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, keep functions small and focused on single tasks, and add docstrings to explain what your functions do. Write comments for complex logic, avoid deep nesting, and use list comprehensions when they improve readability. Also, handle exceptions properly and organize your code into logical modules and classes.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when no references point to them. It also has a cyclic garbage collector to handle circular references between objects. Issues can arise with circular references in large applications, memory leaks from global variables, or performance problems when dealing with many small objects. You can use the `gc` module to manually trigger collection or debug memory issues.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await` and `asyncio.gather()` when handling multiple async operations?",
    "answer": "Using `await` on individual coroutines executes them sequentially, while `asyncio.gather()` runs multiple coroutines concurrently. For example, `await func1(); await func2()` waits for func1 to complete before starting func2, but `await asyncio.gather(func1(), func2())` starts both simultaneously. Use gather when operations are independent and can run in parallel to improve performance.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I choose between using a dictionary or a set in Python?",
    "answer": "Use a set when you only need to store unique values and check membership (like tracking visited items), while use a dictionary when you need key-value pairs for data lookup. Sets are optimized for operations like union, intersection, and difference, while dictionaries excel at mapping relationships. Both offer O(1) average-case lookup time, but dictionaries use more memory due to storing both keys and values.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10) (numbers 0-9), filters for even numbers using `if x % 2 == 0`, and squares each even number with `x**2`. The result would be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a Python function that's running too slowly?",
    "answer": "First, profile your code using tools like cProfile to identify bottlenecks, then consider algorithmic improvements like using better data structures or reducing time complexity. Cache expensive function calls with `functools.lru_cache`, use built-in functions and libraries (like NumPy for numerical operations), and consider moving performance-critical code to compiled extensions. For I/O-bound tasks, implement async/await or multiprocessing for CPU-bound work.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming, allowing your code to handle other tasks while waiting for I/O operations like network requests or file reads. You define async functions with 'async def' and call them with 'await'. Use async/await when dealing with I/O-bound operations, web requests, or when you need to handle multiple concurrent tasks without blocking the main thread.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the most effective way to debug Python code when I'm getting unexpected results?",
    "answer": "Start by using print statements to trace variable values at key points, then upgrade to using Python's built-in debugger (pdb) with 'import pdb; pdb.set_trace()'. Add logging instead of print statements for production code, and use your IDE's debugger to set breakpoints and step through code line by line. Always check your assumptions about data types and variable contents.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "Can you explain what this Python code does: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squared even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result would be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have O(1) average time complexity because dictionaries are implemented as hash tables. However, in the worst case scenario (when many hash collisions occur), it can degrade to O(n). In practice, Python's hash table implementation is highly optimized, so you can expect constant-time lookups for most use cases.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How should I handle exceptions in Python? What's considered best practice?",
    "answer": "Use try/except blocks to catch specific exceptions rather than broad 'except:' statements, and handle exceptions as close to where they occur as possible. Always specify the exception type you're expecting (like 'except ValueError:'), use 'finally' for cleanup code that must run, and consider using 'else' for code that should only run if no exception occurred. Don't use exceptions for normal control flow.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy, and when would I need each?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use shallow copy (copy.copy()) when you want to modify the container but keep references to the same nested objects, and deep copy (copy.deepcopy()) when you need completely independent copies of nested mutable objects.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I properly use asyncio.gather() vs asyncio.create_task()?",
    "answer": "Use asyncio.create_task() to schedule a single coroutine for execution and get a Task object you can cancel or check status on. Use asyncio.gather() when you want to run multiple coroutines concurrently and wait for all of them to complete, returning their results as a list. gather() is ideal for batch operations, while create_task() gives you more control over individual async operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What makes a good variable name in Python?",
    "answer": "Good variable names are descriptive, use lowercase with underscores (snake_case), and clearly indicate the variable's purpose or content. Avoid abbreviations, single letters (except for short loops), and names that don't convey meaning. Use verbs for functions (get_user_data) and nouns for variables (user_count), and make names searchable and pronounceable for better code maintainability.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading and what are the alternatives?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making multithreading ineffective for CPU-bound tasks but still useful for I/O-bound operations. For CPU-bound parallelism, use multiprocessing instead of threading to bypass the GIL, or consider using asyncio for concurrent I/O operations. Libraries like NumPy release the GIL during computations, allowing true multithreading for numerical operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. You need to run async code with asyncio.run() or within an event loop. This allows other code to run while waiting for slow operations to complete, improving performance in I/O-heavy applications.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some effective debugging techniques when my Python code isn't working?",
    "answer": "Start with print statements to trace variable values and program flow, then use Python's built-in debugger (pdb) with 'import pdb; pdb.set_trace()' for interactive debugging. Read error messages carefully - they often point to the exact line and issue. Use IDE debuggers with breakpoints for complex issues, and consider writing unit tests to isolate problems in smaller code sections.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations like get, set, and delete are O(1) average case due to hash table implementation, but O(n) worst case during hash collisions. Iteration through all keys/values is O(n). Dictionary comprehensions and the 'in' operator for key checking are also O(1) average case. This makes dictionaries excellent for lookups and caching compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except:' clauses. Always catch the most specific exception types first, then more general ones. Use 'finally' for cleanup code that must run regardless of success/failure, and 'else' for code that should only run if no exception occurred. Consider logging exceptions and re-raising them when appropriate for debugging.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster and sufficient when you only need to modify the outer container, but deep copy prevents unintended side effects when modifying nested structures.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use a generator instead of a list in Python?",
    "answer": "Use generators when working with large datasets that don't fit in memory, when you only need to iterate through data once, or when you want lazy evaluation. Generators use yield instead of return and produce values on-demand, saving memory. They're perfect for processing files line-by-line, infinite sequences, or expensive computations where you might not need all results.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents true parallelism in CPU-bound multithreaded Python programs by allowing only one thread to execute Python code at a time. However, threading is still beneficial for I/O-bound tasks since the GIL is released during I/O operations. For CPU-intensive parallel processing, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create one?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. Create one by defining a function that takes another function as an argument and returns a wrapper function. Use @decorator_name syntax above function definitions to apply them. Common uses include logging, timing, authentication, and caching functionality.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the best way to format strings in modern Python?",
    "answer": "Use f-strings (formatted string literals) introduced in Python 3.6 for the best performance and readability: f'Hello {name}!'. They're faster than .format() method and much cleaner than % formatting. F-strings support expressions inside braces and formatting specifications like f'{value:.2f}' for decimal places. For Python versions before 3.6, use .format() method instead.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check for common issues like incorrect indentation, variable scope problems, or logic errors in conditional statements. Consider using an IDE with debugging features for a more visual debugging experience.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular synchronous code?",
    "answer": "Use async/await when your program involves I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async programming is ideal for handling multiple concurrent operations without creating multiple threads. It's particularly beneficial for web servers, API clients, or any application that waits for external resources, as it allows other tasks to run while waiting.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case scenario (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using mutable objects as default arguments in Python functions?",
    "answer": "Mutable default arguments are created only once when the function is defined, not each time it's called, leading to unexpected behavior when the object is modified. For example, using an empty list as a default will cause all function calls to share the same list object. Instead, use None as the default and create the mutable object inside the function: 'def func(items=None): items = items or []'.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might I need to worry about it?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles between objects. You typically don't need to manage memory manually, but be aware of potential memory leaks from circular references, large objects in global scope, or unclosed file handles. Use weak references or explicit cleanup when dealing with complex object relationships.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What does this code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using 'if x % 2 == 0', and applies the transformation 'x**2' to each even number. The resulting list will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I handle multiple async operations concurrently and wait for all of them to complete?",
    "answer": "Use asyncio.gather() to run multiple async operations concurrently and wait for all to complete: 'results = await asyncio.gather(async_func1(), async_func2(), async_func3())'. Alternatively, use asyncio.wait() for more control over completion handling. Both methods are more efficient than awaiting each operation sequentially, as they run concurrently rather than one after another.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between __str__ and __repr__ methods in Python classes?",
    "answer": "__str__ is intended to provide a readable, user-friendly string representation of an object, while __repr__ should provide an unambiguous, developer-focused representation that ideally could recreate the object. __str__ is called by str() and print(), while __repr__ is called by repr() and in interactive sessions. If only one is defined, __repr__ serves as a fallback for __str__, so it's often good practice to always define __repr__.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Which sorting algorithm does Python's built-in sort() function use and why?",
    "answer": "Python uses Timsort, a hybrid stable sorting algorithm derived from merge sort and insertion sort, developed specifically for Python by Tim Peters. Timsort performs exceptionally well on real-world data with existing order patterns, achieving O(n log n) worst-case performance while often performing much better on partially sorted data. It's stable (maintains relative order of equal elements) and adaptive (performs better on data that's already partially sorted).",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are typically used when you need to modify the collection, while tuples are used for fixed data that won't change. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access an index that doesn't exist in a sequence. Check that your index is within the valid range (0 to len(sequence)-1 for positive indices). Use print statements to verify the length of your data structure and the index values you're using. You can also use try-except blocks to handle the error gracefully or add conditional checks before accessing elements.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that can benefit from concurrency. Async/await allows your program to handle other tasks while waiting for these operations to complete, improving overall performance. It's particularly useful for web scraping, API calls, or building web servers that handle multiple requests simultaneously.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare in practice. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean functions?",
    "answer": "Follow the single responsibility principle - each function should do one thing well. Use descriptive function names and parameters, write docstrings to document what the function does, and keep functions short (ideally under 20 lines). Avoid global variables, use type hints for clarity, and ensure your functions return consistent data types.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple Python threads from executing bytecode simultaneously, making multithreading ineffective for CPU-bound tasks. However, threads can still be beneficial for I/O-bound operations since the GIL is released during I/O calls. For CPU-bound parallelism, use multiprocessing instead of multithreading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `==` and `is` operators in Python?",
    "answer": "`==` compares the values of two objects for equality, while `is` compares their identity (whether they're the same object in memory). Use `==` when you want to check if two objects have the same content, and `is` when you want to check if they're literally the same object. For example, two lists with identical contents will be `==` but not `is`.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I handle exceptions properly when using async/await?",
    "answer": "Use try-except blocks around await expressions just like synchronous code. For multiple concurrent operations, consider using asyncio.gather() with return_exceptions=True to handle failures gracefully. You can also use asyncio.wait() with proper exception handling in each task, or create wrapper functions that catch and log exceptions before re-raising them.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to remove duplicates from a list while preserving order?",
    "answer": "Use a dictionary or set to track seen elements while iterating through the list. The most Pythonic approach is: `list(dict.fromkeys(original_list))` which leverages dictionary's ordered nature (Python 3.7+). Alternatively, you can use a set with manual iteration: `[x for i, x in enumerate(lst) if x not in lst[:i]]`, though this is less efficient for large lists.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly profile and optimize Python code performance?",
    "answer": "Use the `cProfile` module to identify performance bottlenecks: `python -m cProfile -s cumulative script.py`. For line-by-line profiling, use `line_profiler` with the `@profile` decorator. Focus on optimizing the functions that consume the most time, consider using built-in functions and libraries like NumPy for heavy computations, and profile again after changes to measure improvement.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples also consume less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing without clear error messages?",
    "answer": "Start by adding print statements or using the logging module to trace execution flow and variable values. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at suspected problem areas. For more complex issues, use an IDE debugger to set breakpoints and step through code line by line, examining variable states at each step.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python and what are the benefits?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries where your program waits for external resources. The main benefit is improved performance through concurrency - while one operation waits, others can execute. This is especially valuable in web applications or when processing multiple independent tasks simultaneously.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function and collision resolution make this extremely uncommon. This makes dictionaries ideal for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare 'except' clauses. Always catch the most specific exception type first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions, and consider 'else' for code that should only run if no exceptions occurred.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator checks for value equality (whether two objects have the same content), while 'is' checks for identity equality (whether two variables reference the exact same object in memory). Use '==' for comparing values and 'is' for comparing with None or when you specifically need to check if two variables point to the same object instance.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a Python function that's running too slowly?",
    "answer": "First, profile your code using cProfile or line_profiler to identify bottlenecks. Common optimizations include using list comprehensions instead of loops, leveraging built-in functions, avoiding repeated calculations by caching results, and using appropriate data structures. For mathematical operations, consider NumPy, and for I/O operations, implement async programming or multiprocessing.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between synchronous and asynchronous code execution?",
    "answer": "Synchronous code executes sequentially - each line waits for the previous one to complete before running. Asynchronous code allows multiple operations to run concurrently, where long-running tasks (like network requests) don't block other code from executing. Async code uses async/await keywords and is particularly useful for I/O-bound applications where waiting time can be utilized for other tasks.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search requires a sorted array and works by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n), making it much faster than linear search for large datasets.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create a custom one that measures function execution time?",
    "answer": "Decorators are functions that modify or extend other functions without changing their code directly. To create a timing decorator, define a wrapper function that records start/end times and calculates the difference. Use functools.wraps to preserve the original function's metadata, and return the wrapper function to maintain the decorator pattern.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (changeable) sequences that use square brackets, while tuples are immutable (unchangeable) sequences that use parentheses. You can add, remove, or modify elements in a list after creation, but tuples remain fixed once created. Use lists when you need to modify data, and tuples when you want to ensure data integrity or need hashable objects for dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming in Python with the asyncio library. Use 'async def' to define coroutine functions and 'await' to pause execution until an awaitable completes. This is ideal for I/O-bound operations like web requests, file operations, or database queries where you can perform other tasks while waiting. Always run async functions using asyncio.run() or within an async context.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some common debugging techniques for Python code?",
    "answer": "Start with print statements to trace variable values and execution flow, then use Python's built-in pdb debugger for step-by-step debugging with breakpoints. IDE debuggers provide visual debugging with breakpoint management and variable inspection. Additionally, use logging instead of print statements for production code, and consider tools like pytest for test-driven debugging.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of different operations on Python dictionaries?",
    "answer": "Python dictionaries have O(1) average time complexity for key operations like get, set, and delete due to their hash table implementation. However, in worst-case scenarios with many hash collisions, operations can degrade to O(n). Iteration over all items is O(n), and the space complexity is also O(n) where n is the number of key-value pairs.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare except clauses. Always catch the most specific exception types first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions, and 'else' for code that should only run if no exceptions occurred. Never suppress exceptions silently unless absolutely necessary.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deepcopy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but inserts references to objects found in the original, while deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy is slower but creates completely independent objects.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making threading ineffective for CPU-bound tasks in CPython. However, threading is still useful for I/O-bound operations since threads can release the GIL during I/O waits. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is a decorator in Python and how do I create one?",
    "answer": "A decorator is a function that modifies or extends another function's behavior without permanently modifying it. Create decorators using the @decorator_name syntax above function definitions. Decorators are higher-order functions that take a function as input and return a modified function, commonly used for logging, timing, authentication, or caching functionality.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions are concise ways to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations and filtering. Use them for straightforward operations, but avoid complex nested comprehensions that hurt readability - use regular loops for complex logic instead.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a custom context manager in Python?",
    "answer": "Implement custom context managers using either the contextlib.contextmanager decorator with yield, or by defining a class with __enter__ and __exit__ methods. The __enter__ method sets up the context and returns a value, while __exit__ handles cleanup and exception handling. Context managers ensure proper resource management and are commonly used with the 'with' statement for file handling, database connections, or custom resource management.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (changeable) and use square brackets [1, 2, 3], while tuples are immutable (unchangeable) and use parentheses (1, 2, 3). Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples also use less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and execution flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check for common issues like off-by-one errors, incorrect variable types, or logic errors in conditional statements. Consider using an IDE with debugging features for a more visual approach.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await for I/O-bound operations like network requests, file operations, or database queries where you're waiting for external resources. It's particularly beneficial when you need to handle multiple concurrent operations without blocking the main thread. However, avoid it for CPU-intensive tasks as it won't provide performance benefits and may add unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations in Python have O(1) average time complexity for lookup, insertion, and deletion due to hash table implementation. However, in worst-case scenarios (many hash collisions), these operations can degrade to O(n). Iterating through all keys, values, or items is O(n) where n is the number of elements.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically deallocating objects when their reference count reaches zero. It also employs a cyclic garbage collector to handle reference cycles that reference counting can't resolve. The collector runs periodically and uses a generational approach, checking younger objects more frequently since they're more likely to become garbage.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting and naming conventions. Write descriptive variable and function names, keep functions small and focused on single responsibilities, and add docstrings for documentation. Use list comprehensions judiciously, handle exceptions appropriately, and avoid deep nesting by using early returns or guard clauses.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the basic structure: use two pointers (left, right), calculate mid = (left + right) // 2, and update pointers based on comparison until found or pointers cross.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await' and 'yield' in Python?",
    "answer": "'await' is used in async functions to pause execution until an awaitable object completes, allowing other coroutines to run meanwhile. 'yield' is used in generator functions to produce values one at a time, pausing execution and resuming from the same point when next() is called. 'await' is for asynchronous programming, while 'yield' is for creating iterators and generators.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare 'except' clauses. Always catch the most specific exception types first, and use 'finally' blocks for cleanup code that must run regardless of success or failure. Consider using 'else' clause for code that should only run if no exception occurred, and avoid using exceptions for normal program flow control.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are the performance implications of using asyncio.gather() vs asyncio.create_task()?",
    "answer": "asyncio.gather() is ideal for running multiple coroutines concurrently and collecting all results, but it waits for all tasks to complete before returning. asyncio.create_task() gives you more control by immediately scheduling a coroutine and returning a Task object you can await later, cancel, or check status. Use gather() for simple concurrent execution, and create_task() when you need fine-grained control over individual tasks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets [], while a tuple is immutable (cannot be changed after creation) and uses parentheses (). Lists are good for collections that need to be modified, while tuples are better for data that shouldn't change, like coordinates or database records. Tuples also use less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running slowly?",
    "answer": "Start by using the cProfile module to identify bottlenecks: `python -m cProfile -s cumulative your_script.py`. Look for functions with high cumulative time or many calls. You can also add timing statements around suspicious code blocks using `time.time()` or use line profilers like `line_profiler` for more granular analysis. Consider optimizing data structures, reducing nested loops, or using built-in functions which are typically faster than custom implementations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does async/await do in Python and when should I use it?",
    "answer": "Async/await enables asynchronous programming, allowing your program to handle multiple tasks concurrently without blocking. Use `async def` to define coroutines and `await` to pause execution until an awaitable completes. This is ideal for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources. It's not helpful for CPU-intensive tasks since Python's GIL still applies.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is Big O notation and why is it important?",
    "answer": "Big O notation describes how an algorithm's performance scales with input size, focusing on the worst-case scenario. For example, O(1) is constant time, O(n) is linear, and O(n\u00b2) is quadratic. It helps you choose efficient algorithms and predict how your code will perform with larger datasets. Understanding Big O is crucial for writing scalable code and passing technical interviews.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I properly handle exceptions in Python without catching too broadly?",
    "answer": "Catch specific exceptions rather than using bare `except:` clauses, and handle each exception type appropriately. Use multiple except blocks for different error types, and consider using `except Exception as e:` only when you truly need to catch all exceptions. Always log or handle the exception meaningfully, and use `finally` blocks for cleanup code that must run regardless of success or failure.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `==` and `is` in Python?",
    "answer": "`==` compares values for equality, while `is` checks if two variables reference the same object in memory. Use `==` to compare content and `is` for identity comparison. The most common use of `is` is checking for None: `if x is None:`. For small integers and string literals, Python may reuse objects, so `is` might work unexpectedly, but you should still use `==` for value comparisons.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the key insight: each comparison eliminates half the remaining elements, giving O(log n) time complexity. Implementation requires careful handling of indices to avoid infinite loops.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create a simple one?",
    "answer": "Decorators are functions that modify or enhance other functions without changing their code directly. They use the `@decorator_name` syntax above function definitions. A simple decorator takes a function as argument, defines a wrapper function inside, and returns the wrapper. The wrapper can execute code before/after calling the original function, modify arguments, or change the return value.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I avoid blocking the event loop when using asyncio?",
    "answer": "Never use blocking operations like `time.sleep()`, synchronous file I/O, or blocking network calls inside async functions. Use their async equivalents: `asyncio.sleep()`, `aiofiles`, and `aiohttp`. For CPU-intensive tasks, use `asyncio.run_in_executor()` to run them in a thread pool. Always `await` coroutines and use `asyncio.gather()` or `asyncio.create_task()` for concurrent execution.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use `list.copy()` or `copy.copy()` for shallow copies, and `copy.deepcopy()` for deep copies. Shallow copies are faster but changes to nested mutable objects affect both copies, while deep copies are independent but use more memory and time.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples also have better performance and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic with small test cases and verify that your inputs match what the function expects. Modern IDEs also provide visual debuggers that let you set breakpoints and step through code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular synchronous code?",
    "answer": "Use async/await when your program does I/O operations like network requests, file reading, or database queries that involve waiting. Async code allows other tasks to run while waiting for slow operations to complete, improving overall performance. However, avoid async for CPU-intensive tasks or simple scripts where the overhead isn't worth it. The benefit comes from concurrency, not parallelism.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of inserting an element at the beginning of a Python list?",
    "answer": "Inserting at the beginning of a Python list has O(n) time complexity because all existing elements must be shifted one position to the right. This makes frequent insertions at the beginning inefficient for large lists. If you need frequent insertions at the beginning, consider using collections.deque which has O(1) insertion time at both ends, or rethink your algorithm to append at the end instead.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions without catching too broadly?",
    "answer": "Catch specific exceptions rather than using bare 'except:' clauses, which can hide bugs and make debugging difficult. Use multiple except blocks for different exception types when you need different handling strategies. Always consider whether you can actually handle the exception meaningfully - sometimes it's better to let it propagate up to a caller that has more context. Use 'finally' blocks for cleanup code that must run regardless of success or failure.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does the 'await' keyword actually do in Python async code?",
    "answer": "The 'await' keyword pauses the execution of the current coroutine and yields control back to the event loop, allowing other tasks to run. It can only be used inside async functions and only with awaitable objects (coroutines, tasks, or futures). When the awaited operation completes, execution resumes from that point with the result. This enables cooperative multitasking where tasks voluntarily yield control during I/O operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using mutable default arguments in Python functions?",
    "answer": "Mutable default arguments (like lists or dictionaries) are created only once when the function is defined, not each time it's called. This means all calls to the function share the same object, leading to unexpected behavior when the object is modified. Instead, use None as the default and create a new mutable object inside the function if needed. This is one of Python's most common gotchas for new developers.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work with reference cycles?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, but this can't handle reference cycles where objects reference each other. Python's cyclic garbage collector runs periodically to detect and clean up these cycles by finding groups of objects that only reference each other but aren't referenced from anywhere else. You can manually trigger this with gc.collect() or disable it entirely, though this is rarely needed. Weak references can also help break cycles when appropriate.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks for identity (whether two variables refer to the same object in memory), while '==' checks for equality (whether two objects have the same value). Use '==' for comparing values and 'is' for comparing with singleton objects like None, True, or False. Small integers and short strings are cached by Python, so 'is' might work unexpectedly with them, but you should still use '==' for value comparisons.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a recursive algorithm that has overlapping subproblems?",
    "answer": "Use memoization to cache results of expensive function calls, either with a dictionary or Python's @lru_cache decorator from functools. This prevents recalculating the same subproblems multiple times. Alternatively, convert to dynamic programming with bottom-up iteration instead of recursion. For very deep recursion, also consider increasing Python's recursion limit with sys.setrecursionlimit(), though iterative solutions are often more robust.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that would otherwise block your program. Async programming allows other code to run while waiting for these operations to complete, improving overall performance. It's particularly useful for web servers, API clients, and applications that handle multiple concurrent operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an unexpected exception?",
    "answer": "Start by reading the traceback carefully to identify the exact line and error type. Add print statements or use the built-in debugger (pdb) to inspect variable values at different points. Use try-except blocks to catch specific exceptions and log relevant information. Consider using an IDE with debugging features or logging modules for more complex debugging scenarios.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Most dictionary operations like lookup, insertion, and deletion are O(1) on average due to hash table implementation. However, in worst-case scenarios with many hash collisions, they can degrade to O(n). Iteration over all keys, values, or items is O(n) where n is the number of elements. Dictionary comprehensions and methods like keys(), values(), and items() are also O(n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using global variables in my code?",
    "answer": "Global variables make code harder to test, debug, and maintain because any function can modify them, creating unpredictable side effects. They also make functions less reusable since they depend on external state. Instead, pass data as function parameters and return values, or use classes to encapsulate related data and behavior.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's GIL affect multithreading performance?",
    "answer": "The Global Interpreter Lock (GIL) allows only one thread to execute Python bytecode at a time, which limits true parallelism for CPU-bound tasks. However, threading can still be beneficial for I/O-bound operations since the GIL is released during I/O waits. For CPU-intensive parallel processing, consider using multiprocessing instead of threading, or async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between BFS and DFS algorithms?",
    "answer": "Breadth-First Search (BFS) explores nodes level by level using a queue, guaranteeing the shortest path in unweighted graphs. Depth-First Search (DFS) explores as far as possible along each branch using a stack or recursion. BFS uses more memory but finds optimal solutions, while DFS uses less memory and is better for exploring all possible paths or detecting cycles.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use specific exception types rather than bare except clauses to catch only the errors you can handle. Always include appropriate error messages and consider logging exceptions for debugging. Use try-except-else-finally blocks appropriately: else runs when no exception occurs, finally always runs for cleanup. Avoid catching and ignoring exceptions without proper handling.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work internally?",
    "answer": "Decorators are functions that modify or extend other functions without changing their source code. They work by taking a function as input and returning a modified version, essentially implementing the wrapper pattern. Internally, @decorator syntax is syntactic sugar for func = decorator(func). Decorators can be stacked, parameterized, and are commonly used for logging, authentication, caching, and timing.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Which sorting algorithm should I choose for different scenarios?",
    "answer": "For general-purpose sorting, use Python's built-in sorted() or list.sort() which implement Timsort (O(n log n)). For educational purposes: quicksort is efficient on average (O(n log n)) but worst-case O(n\u00b2), mergesort is stable with guaranteed O(n log n), and heapsort guarantees O(n log n) with O(1) space. Consider insertion sort for small datasets and counting sort for integers with limited range.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to change, like a shopping cart, while tuples are good for fixed data like coordinates. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing with no clear error message?",
    "answer": "Start by adding print statements or using the logging module to trace where the code stops working. Use try-except blocks to catch and display specific exceptions, and consider running your code in smaller chunks to isolate the problem. Python's built-in debugger (pdb) can also help you step through code line by line to find the issue.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program does a lot of I/O operations like making HTTP requests, reading files, or database queries that would otherwise block execution. It's particularly useful when you need to handle multiple operations concurrently without creating multiple threads. However, avoid it for CPU-intensive tasks as it won't provide performance benefits there.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is Big O notation and why does it matter?",
    "answer": "Big O notation describes how an algorithm's performance changes as the input size grows, focusing on worst-case scenarios. It matters because it helps you choose efficient algorithms - for example, a O(n) algorithm will scale much better than O(n\u00b2) as your data grows. Understanding Big O helps you write code that remains fast even with large datasets.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than catching all exceptions with a bare 'except'. Always handle the most specific exceptions first, and consider using 'finally' for cleanup code that must run regardless of success or failure. For example: try your risky code, except ValueError for specific value errors, and include meaningful error messages for debugging.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between await and asyncio.gather() in Python?",
    "answer": "await pauses execution until a single async operation completes, running operations sequentially. asyncio.gather() runs multiple async operations concurrently and waits for all of them to complete, returning results in the same order as the input. Use gather() when you have independent operations that can run simultaneously for better performance.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid global variables in my code?",
    "answer": "Global variables make code harder to debug, test, and understand because any function can modify them unexpectedly. They create hidden dependencies between functions and make it difficult to track where values change. Instead, pass variables as parameters and return values explicitly - this makes your code more predictable and easier to maintain.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when no references to them exist. It also has a cyclic garbage collector for circular references. Issues can arise with circular references in large applications, memory leaks in C extensions, or performance hiccups during collection cycles. You can use gc module to monitor and tune garbage collection behavior.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of common dictionary operations in Python?",
    "answer": "Dictionary operations in Python are generally O(1) average case due to hash table implementation: lookup, insertion, and deletion are all constant time on average. However, in worst-case scenarios (with many hash collisions), these operations can degrade to O(n). This makes dictionaries excellent for fast lookups but less predictable for real-time systems.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I choose between a list, set, and dictionary for storing data?",
    "answer": "Use lists when you need ordered data that can contain duplicates and require indexed access. Use sets for unique items where you need fast membership testing and don't care about order. Use dictionaries when you need to associate keys with values for fast lookups. Consider your main operations: lists for iteration and indexing, sets for membership tests, dictionaries for key-based retrieval.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for data that shouldn't change, like coordinates or database records. Tuples are also more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but producing wrong results?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at problematic lines to step through code interactively. Consider using an IDE with debugging features, and write unit tests to isolate and verify individual functions work correctly.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. It's particularly beneficial when you need to handle multiple concurrent operations, such as web scraping multiple URLs or handling many client connections in a web server. Avoid async/await for CPU-intensive tasks as it won't provide performance benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. However, in the worst case scenario (many hash collisions), it can degrade to O(n). In practice, Python's hash table implementation is highly optimized and collisions are rare, so you can expect constant-time lookups for most real-world use cases.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare except clauses, and handle different exception types appropriately. Always catch the most specific exception first, then more general ones, and consider using finally blocks for cleanup code that must run regardless of exceptions. Use 'raise' to re-raise exceptions when you need to log but not handle them, and create custom exceptions for application-specific errors.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `[x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result would be [0, 4, 16, 36, 64], representing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I avoid race conditions when using async/await with shared resources?",
    "answer": "Use asyncio.Lock() to create locks that prevent multiple coroutines from accessing shared resources simultaneously. Wrap critical sections with 'async with lock:' to ensure only one coroutine can execute that code at a time. For more complex scenarios, consider using asyncio.Semaphore() to limit the number of concurrent accesses, or asyncio.Queue() for safe communication between coroutines.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "'==' checks if two objects have the same value (calls the __eq__ method), while 'is' checks if two variables reference the exact same object in memory. Use '==' for value comparison and 'is' for identity comparison, typically with None, True, False, or when you specifically need to check object identity. For example, 'x == y' might be True even if 'x is y' is False.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Continue until found or the search space is empty. The time complexity is O(log n), making it much faster than linear search for large datasets.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work under the hood?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying their code. They work by taking a function as an argument and returning a modified version, leveraging Python's first-class function support. When you use @decorator syntax, it's syntactic sugar for 'func = decorator(func)'. Common uses include logging, authentication, timing, and caching functionality.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is a mutable data structure that can be modified after creation, while a tuple is immutable and cannot be changed once created. Lists use square brackets [] and tuples use parentheses (). Use lists when you need to modify the data, and tuples when you want to ensure the data remains constant or need a hashable type for dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but producing unexpected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Consider using an IDE with debugging capabilities or logging instead of print statements for more complex applications.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python and what are the benefits?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async programming allows other tasks to run while waiting for these operations to complete, improving performance for I/O-bound applications. It's particularly useful for web scraping, API calls, or handling multiple concurrent connections in web servers.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "The average time complexity for searching in a Python dictionary is O(1) due to its hash table implementation. In the worst case scenario (when many hash collisions occur), it can degrade to O(n), but this is extremely rare in practice. This makes dictionaries very efficient for lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and write docstrings for functions and classes. Keep functions small and focused on a single responsibility, avoid deeply nested code, and use list comprehensions judiciously. Always handle exceptions appropriately and prefer explicit code over clever shortcuts that reduce readability.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might I need to worry about it?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deleting objects when their reference count reaches zero. It also has a cycle detector to handle circular references between objects. You typically only need to worry about garbage collection when dealing with large datasets, circular references, or when integrating with C extensions that don't follow Python's memory management rules.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' operators in Python?",
    "answer": "The '==' operator compares the values of two objects to see if they're equal, while 'is' compares their identities (memory addresses) to see if they're the same object. Use '==' for value comparison and 'is' for identity comparison, particularly with None, True, False, or when you specifically need to check if two variables reference the same object. For example, 'x is None' is preferred over 'x == None'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I handle multiple async operations concurrently in Python?",
    "answer": "Use asyncio.gather() to run multiple coroutines concurrently and wait for all to complete, or asyncio.create_task() to schedule individual coroutines. For more control, use asyncio.as_completed() to process results as they finish, or asyncio.wait() with different return conditions. Always use 'await' when calling these functions, and consider using asyncio.Semaphore() to limit concurrency if needed.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is a Python decorator and can you give a simple example?",
    "answer": "A decorator is a function that modifies or extends the behavior of another function without permanently modifying its code. It uses the @decorator_name syntax above a function definition. For example: '@property' creates a getter method, or you can create custom decorators like '@timer' to measure execution time. Decorators follow the pattern of taking a function as input and returning a modified function.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to find the intersection of two large lists in Python?",
    "answer": "Convert both lists to sets and use the intersection operator (&) or intersection() method: 'set(list1) & set(list2)'. This approach has O(n + m) time complexity compared to O(n * m) for nested loops. If you need to preserve duplicates or order, consider using collections.Counter for multiset operations or convert back to a list after the set operation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples also use less memory and can be used as dictionary keys, unlike lists.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming to handle I/O-bound operations without blocking the main thread. Use 'async def' to define a coroutine function and 'await' to pause execution until the awaited operation completes. It's most beneficial for operations like web requests, file I/O, or database queries where you're waiting for external resources.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the best way to debug a Python script that's crashing?",
    "answer": "Start by reading the error traceback carefully to identify the line and type of error. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. For systematic debugging, use an IDE debugger to set breakpoints and step through code line by line. Always reproduce the error in the smallest possible code example.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is Big O notation and why does it matter for algorithms?",
    "answer": "Big O notation describes how an algorithm's runtime or space usage grows as input size increases, focusing on the worst-case scenario. It helps you compare algorithm efficiency and predict performance at scale. For example, O(1) is constant time, O(n) is linear, and O(n\u00b2) is quadratic - knowing this helps you choose the right algorithm for your data size.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you properly handle exceptions in Python without catching everything?",
    "answer": "Use specific exception types instead of bare 'except:' clauses to catch only the errors you can actually handle. Follow the EAFP principle (Easier to Ask for Forgiveness than Permission) by attempting operations and handling specific failures. Always include meaningful error messages and consider whether to log, re-raise, or transform exceptions based on your application's needs.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between == and 'is' in Python?",
    "answer": "The == operator compares values for equality, while 'is' compares object identity (whether two variables refer to the same object in memory). Use == when you want to check if two things have the same value, and use 'is' when checking for None or comparing with singleton objects. For example, 'x is None' is preferred over 'x == None'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do you implement a thread-safe singleton pattern in Python?",
    "answer": "Use a combination of double-checked locking with threading.Lock or leverage Python's module import mechanism which is thread-safe by default. The most Pythonic approach is often using a module-level variable or implementing __new__ with proper locking. Alternatively, use the @functools.lru_cache decorator on a factory function for a clean, thread-safe singleton implementation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copies are faster but changes to nested mutable objects affect both copies, while deep copies are independent but use more memory.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you optimize a Python function that's running too slowly?",
    "answer": "First, profile your code using cProfile or line_profiler to identify bottlenecks. Common optimizations include using built-in functions, list comprehensions instead of loops, and avoiding repeated calculations by caching results. Consider using NumPy for numerical operations or moving critical sections to Cython. Sometimes algorithmic improvements provide better gains than micro-optimizations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do you use them?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. They use the @decorator_name syntax above function definitions and are commonly used for logging, authentication, or timing. Decorators work by taking a function as input and returning a modified version, allowing you to add functionality in a clean, reusable way.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are typically used for collections of similar items that may change, while tuples are used for fixed collections like coordinates or database records. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access an index that doesn't exist in a sequence. Add print statements to check the length of your list/string and the index values you're using. Use try-except blocks to catch the error gracefully, and consider using len() to verify bounds before accessing elements. Python's debugger (pdb) can also help you step through the code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does async/await do in Python and when should I use it?",
    "answer": "async/await enables asynchronous programming, allowing your code to handle multiple tasks concurrently without blocking. Use async def to define coroutines and await to pause execution until an async operation completes. This is ideal for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources. It improves performance by letting other code run while waiting for slow operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists, which have O(n) search time. Insertions and deletions are also O(1) on average.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I improve the performance of this nested loop code?",
    "answer": "Common optimizations include: moving invariant calculations outside loops, using list comprehensions or generator expressions, leveraging built-in functions like map() or filter(), and considering algorithmic improvements like using sets for membership testing O(1) instead of lists O(n). For large datasets, consider using libraries like NumPy for vectorized operations. Profile your code first to identify actual bottlenecks before optimizing.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's magic methods and give me an example?",
    "answer": "Magic methods (dunder methods) are special methods surrounded by double underscores that define how objects behave with built-in operations. For example, __len__() defines what happens when you call len() on your object, and __str__() defines the string representation. Here's an example: class Person: def __init__(self, name): self.name = name; def __str__(self): return f'Person({self.name})' - now print(person_obj) will use your custom string format.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions when using async/await?",
    "answer": "Use try-except blocks around await statements just like synchronous code, but be aware that exceptions in one coroutine don't automatically propagate to others. When using asyncio.gather() or similar, exceptions will be raised when you await the gathered result. For fire-and-forget tasks, consider using asyncio.create_task() with exception handling or asyncio.gather(return_exceptions=True) to collect exceptions instead of raising them.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between is and == in Python?",
    "answer": "The == operator compares values for equality, while is compares object identity (whether two variables point to the same object in memory). Use == when you want to check if two things have the same value, and is when checking if they're literally the same object. For example: [1,2,3] == [1,2,3] is True, but [1,2,3] is [1,2,3] is False because they're different list objects with the same content.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple Python threads from executing bytecode simultaneously, making threading ineffective for CPU-bound tasks in CPython. However, threads can still be beneficial for I/O-bound operations since the GIL is released during I/O calls. For CPU-intensive parallel processing, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency. Alternative Python implementations like Jython and IronPython don't have a GIL.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the best way to implement a binary search algorithm in Python?",
    "answer": "Use two pointers (left and right) to track the search range, calculate the middle index, and eliminate half the search space each iteration. The key is maintaining the invariant that the target, if present, is always within [left, right]. Here's the pattern: while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1. Time complexity is O(log n).",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be modified after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to change, while tuples are ideal for fixed data like coordinates or database records. Tuples also use less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming, allowing your program to handle other tasks while waiting for I/O operations. You define async functions with 'async def' and call them with 'await'. Use async/await when dealing with I/O-bound operations like web requests, file operations, or database queries where you want to avoid blocking the entire program while waiting.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to find duplicates in a Python list?",
    "answer": "Use a set to track seen elements: iterate through the list and add items to both a 'seen' set and a 'duplicates' set if already seen. This approach is O(n) time complexity. Alternatively, you can use collections.Counter to count occurrences and filter items with count > 1.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why am I getting an IndentationError in my Python code?",
    "answer": "IndentationError occurs when Python can't understand your code's structure due to inconsistent spacing or tabs. Python uses indentation to define code blocks instead of curly braces. Make sure you consistently use either spaces (recommended 4 spaces) or tabs throughout your code, and ensure proper indentation after colons in functions, classes, loops, and conditionals.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between '==' and 'is' in Python?",
    "answer": "The '==' operator checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables reference the exact same object in memory). Use '==' to compare values and 'is' only when you need to check if two variables point to the same object, like when comparing to None.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a recursive function that's causing stack overflow?",
    "answer": "Convert to an iterative solution using a stack or queue data structure, implement memoization to cache results of expensive function calls, or use tail recursion optimization if your language supports it. For Python specifically, consider using the @lru_cache decorator from functools for automatic memoization, or increase the recursion limit with sys.setrecursionlimit() as a temporary measure.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested objects affect both copies, while deep copy is slower but provides complete independence.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch and handle specific exceptions, always specify the exception type rather than using bare 'except'. Include 'finally' blocks for cleanup code that must run regardless of exceptions. Follow the principle of catching specific exceptions first, then more general ones, and avoid catching all exceptions unless absolutely necessary.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations like lookup, insertion, and deletion are average case O(1) due to hash table implementation, but worst case O(n) when hash collisions occur. Iterating through all keys/values is O(n). Dictionary comprehensions and the update() method are also O(n) where n is the number of items being processed.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's running but not producing expected output?",
    "answer": "Use print statements strategically to trace variable values and execution flow, or use Python's built-in debugger (pdb) with pdb.set_trace() for interactive debugging. Check your logic with simple test cases, verify input data format and types, and use IDE debuggers to step through code line by line. Also consider using logging instead of print for more structured debugging output.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is a mutable data structure that can be modified after creation, while a tuple is immutable and cannot be changed once created. Lists use square brackets [] and are ideal for collections that need to be updated, whereas tuples use parentheses () and are perfect for fixed data like coordinates or database records. Lists have more methods available for modification, but tuples are more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access an index that doesn't exist in a sequence. Add print statements to check the length of your list/string and the index values you're using, or use a debugger to step through the code. Consider using try-except blocks to handle the error gracefully, or validate that your index is within the valid range (0 to len(sequence)-1) before accessing it.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular synchronous code?",
    "answer": "Use async/await when your code involves I/O-bound operations like network requests, file operations, or database queries that would otherwise block execution. Async code allows other tasks to run while waiting for these operations to complete, improving overall performance and responsiveness. However, avoid async for CPU-bound tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst-case scenario (when there are many hash collisions), it can degrade to O(n), but this is rare with Python's optimized hash function. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await with multiple concurrent operations?",
    "answer": "Use asyncio.gather() with return_exceptions=True to collect results and exceptions from multiple concurrent operations, then check each result individually. Alternatively, wrap each async operation in a try-except block or use asyncio.wait() with return_when parameter for more granular control. For critical applications, consider using asyncio.TaskGroup (Python 3.11+) which provides structured concurrency and automatic exception handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions are a concise way to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations and filtering operations. Use them for straightforward operations, but avoid them for complex logic where a regular loop would be clearer.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to the objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, whereas deep copy is slower but creates completely independent objects.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading performance?",
    "answer": "The GIL prevents multiple native threads from executing Python bytecode simultaneously, making threading ineffective for CPU-bound tasks in Python. However, threading is still beneficial for I/O-bound tasks since the GIL is released during I/O operations. For CPU-bound parallelism, use multiprocessing instead, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the purpose of the __init__ method in Python classes?",
    "answer": "The __init__ method is a constructor that initializes a new instance of a class when an object is created. It's automatically called when you create an object and allows you to set initial values for instance attributes. The first parameter is always 'self', which refers to the instance being created, followed by any additional parameters needed for initialization.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I optimize a Python function that's running slowly due to repeated expensive computations?",
    "answer": "Use memoization with functools.lru_cache decorator to cache function results, avoiding redundant calculations for the same inputs. Profile your code with cProfile to identify bottlenecks, consider using more efficient data structures or algorithms, and move computationally expensive operations outside loops when possible. For mathematical operations, libraries like NumPy can provide significant speed improvements over pure Python.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better when you need to modify the collection, while tuples are ideal for fixed data that shouldn't change. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python for making HTTP requests?",
    "answer": "Use async/await with libraries like aiohttp or httpx for asynchronous HTTP requests. Define your function with 'async def' and use 'await' when calling the HTTP request method. This allows other code to run while waiting for the network response, improving performance when making multiple requests concurrently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have O(1) average time complexity due to hash table implementation. In the worst case (with many hash collisions), it could degrade to O(n), but this is rare in practice. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's not working as expected?",
    "answer": "Start by adding print statements to track variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at breakpoints. Many IDEs also offer visual debuggers that let you step through code line by line and inspect variables in real-time.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result would be [0, 4, 16, 36, 64] representing 0\u00b2, 2\u00b2, 4\u00b2, 6\u00b2, and 8\u00b2.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between asyncio.gather() and asyncio.create_task()?",
    "answer": "asyncio.create_task() schedules a single coroutine to run concurrently and returns a Task object immediately. asyncio.gather() runs multiple coroutines concurrently and waits for all of them to complete, returning their results as a list. Use create_task() when you want to start a task and potentially await it later, and gather() when you want to run multiple tasks simultaneously.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using mutable objects as default arguments in Python functions?",
    "answer": "Mutable default arguments are evaluated only once when the function is defined, not each time it's called. This means the same object is reused across function calls, leading to unexpected behavior where modifications persist between calls. Instead, use None as the default and create the mutable object inside the function body.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles where objects reference each other. The collector runs periodically and uses generational collection, checking newer objects more frequently since they're more likely to become garbage.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator compares the values of two objects to see if they're equal, while 'is' compares their identities (memory addresses) to see if they're the same object. Use '==' to check if objects have the same content, and 'is' to check if they're literally the same object in memory. It's common to use 'is' with None comparisons.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do you implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n), making it much faster than linear search for large datasets.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples also consume less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "async/await is used for asynchronous programming, allowing your program to handle multiple operations concurrently without blocking. Define functions with 'async def' and use 'await' to call other async functions or awaitable objects. It's best for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result will be [0, 4, 16, 36, 64], representing 0\u00b2, 2\u00b2, 4\u00b2, 6\u00b2, and 8\u00b2.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's throwing an unexpected exception?",
    "answer": "Use Python's built-in debugger (pdb) by adding `import pdb; pdb.set_trace()` at the problematic line, or run your script with `python -m pdb script.py`. You can also add strategic print statements to trace variable values, or use try/except blocks to catch and examine specific exceptions. Modern IDEs also provide visual debuggers with breakpoints and variable inspection.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to their hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but this is uncommon with Python's optimized hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists which require O(n) linear search.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 for code formatting, use descriptive variable and function names, and write docstrings for functions and classes. Keep functions small and focused on single responsibilities, handle exceptions appropriately, and use list comprehensions when they improve readability. Always validate input data and prefer explicit code over implicit 'clever' solutions.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle multiple async operations that can run concurrently?",
    "answer": "Use `asyncio.gather()` for multiple operations that should all complete, or `asyncio.as_completed()` to process results as they finish. For more control, create tasks with `asyncio.create_task()` and await them individually or in groups. Always handle exceptions properly with try/except blocks, as unhandled exceptions in async code can be silently ignored.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `==` and `is` in Python?",
    "answer": "`==` compares the values of objects for equality, while `is` checks if two variables reference the exact same object in memory. Use `==` to compare contents (like comparing two lists with same elements) and `is` for identity comparison (typically with None, True, False). For example, two separate lists with identical contents will be equal (`==`) but not identical (`is`).",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the key: `mid = (left + right) // 2`, then adjust `left = mid + 1` or `right = mid - 1` based on comparison. Time complexity is O(log n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work internally?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying their code. They work by taking a function as input and returning a modified version, leveraging Python's first-class functions and closures. When you use @decorator syntax, it's syntactic sugar for `func = decorator(func)`. Decorators can accept arguments, be stacked, and are commonly used for logging, authentication, and caching.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or database records.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing a KeyError?",
    "answer": "A KeyError occurs when trying to access a dictionary key that doesn't exist. Use try-except blocks to handle it gracefully, or check if the key exists first with 'if key in dictionary'. You can also use dictionary.get(key, default_value) to return a default value instead of raising an error.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries where your program waits for external resources. It allows other code to run while waiting, improving performance in applications that handle many concurrent operations. Don't use it for CPU-intensive tasks as it won't provide benefits there.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Searching in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize collisions. This makes dictionaries extremely efficient for lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, write docstrings for functions and classes, and keep functions small and focused on a single task. Additionally, use meaningful comments for complex logic, avoid deep nesting with guard clauses, and organize code into modules and packages logically.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await' and 'asyncio.gather()' when handling multiple async operations?",
    "answer": "Using 'await' on multiple operations runs them sequentially (one after another), while 'asyncio.gather()' runs them concurrently. For example, 'await func1(); await func2()' waits for func1 to complete before starting func2, but 'await asyncio.gather(func1(), func2())' starts both simultaneously and waits for both to complete.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. This gives O(log n) time complexity, much faster than linear search's O(n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying them. They use the @ syntax and work by wrapping the original function with additional functionality. Common uses include logging, timing, authentication, and caching, following the principle of separation of concerns.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why am I getting an IndentationError in my Python code?",
    "answer": "IndentationError occurs when Python can't understand your code's structure due to inconsistent spacing or mixing tabs and spaces. Python uses indentation to define code blocks instead of braces. Ensure you use consistent indentation (4 spaces is recommended) and check that all lines in the same block have identical indentation.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in async functions?",
    "answer": "Use try-except blocks around await statements just like synchronous code, but be aware that exceptions in background tasks might be silently ignored. Use asyncio.gather(return_exceptions=True) to collect exceptions instead of raising them immediately, and consider using asyncio.create_task() with proper exception handling for fire-and-forget operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async and await in Python?",
    "answer": "Use 'async def' to define an asynchronous function and 'await' to pause execution until an awaitable operation completes. You need to run async functions using asyncio.run() or within another async function. This allows other code to run while waiting for I/O operations like network requests or file operations, improving performance in I/O-bound applications.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of inserting an element at the beginning of a Python list?",
    "answer": "Inserting at the beginning of a Python list using list.insert(0, item) has O(n) time complexity because all existing elements need to be shifted one position to the right. If you frequently need to add elements at the beginning, consider using collections.deque which provides O(1) insertion at both ends. For occasional insertions, regular lists are fine, but for high-frequency operations, deque is more efficient.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python program that's not working as expected?",
    "answer": "Start by adding print statements to check variable values at different points in your code. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Most IDEs also offer visual debugging tools with breakpoints and variable inspection. Reading error messages carefully and using try-except blocks can also help identify and handle issues.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value (equality), while 'is' checks if two variables reference the exact same object in memory (identity). Use '==' to compare values and 'is' to compare object identity, typically with None, True, False, or when you specifically need to check if variables point to the same object. For example, 'x == y' checks if they're equal, while 'x is y' checks if they're the same object.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a simple implementation: 'def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left+right)//2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid+1; else: right = mid-1; return -1'. Time complexity is O(log n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and write docstrings for your functions. Keep functions small and focused on a single task, handle exceptions appropriately with try-except blocks, and avoid global variables when possible. Use list comprehensions for simple operations but prioritize readability over cleverness.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use asyncio.gather() vs asyncio.create_task()?",
    "answer": "Use asyncio.gather() when you want to run multiple coroutines concurrently and wait for all of them to complete, returning results in the same order as input. Use asyncio.create_task() when you want to schedule a single coroutine to run concurrently but continue with other code immediately. gather() is better for batch operations, while create_task() gives you more control over individual task lifecycle and allows you to cancel specific tasks if needed.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I handle memory leaks when working with large datasets in Python?",
    "answer": "Use generators and iterators instead of loading entire datasets into memory, process data in chunks, and explicitly delete large objects with 'del' when done. Monitor memory usage with tools like memory_profiler, use context managers for file operations, and consider using libraries like pandas with chunksize parameter for large files. Be careful with circular references and use weak references when appropriate to help the garbage collector.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between append() and extend() methods for Python lists?",
    "answer": "append() adds a single element to the end of a list, even if that element is itself a list. extend() adds each element from an iterable (like another list) individually to the end of the list. For example, list.append([1,2]) adds the entire list as one element, while list.extend([1,2]) adds 1 and 2 as separate elements. Use append() for single items and extend() to merge lists or add multiple items at once.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists support operations like append() and remove(), but tuples do not. Use lists when you need to modify data, and tuples for fixed collections or as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's not producing the expected output?",
    "answer": "Start by adding print() statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step-by-step and verify that your input data matches expectations. Most IDEs also provide visual debugging tools with breakpoints.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. It's particularly useful when you need to handle multiple operations concurrently, such as fetching data from multiple APIs simultaneously. Async programming improves performance by allowing other code to run while waiting for slow operations to complete.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a hash table (dictionary) versus a list?",
    "answer": "Hash tables (Python dictionaries) have O(1) average time complexity for lookups, while lists have O(n) time complexity for searching. This means dictionary lookups are nearly constant time regardless of size, but searching through a list takes longer as the list grows. However, dictionaries use more memory and don't maintain insertion order in older Python versions.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare except clauses. Always catch the most specific exception types first, then more general ones. Use 'finally' blocks for cleanup code that must run regardless of whether an exception occurred. Consider using 'else' blocks for code that should only run if no exceptions were raised in the try block.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copies are faster but changes to nested mutable objects affect both copies, whereas deep copies are independent but slower and use more memory.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my async function handle multiple tasks concurrently?",
    "answer": "Use asyncio.gather() to run multiple coroutines concurrently and wait for all to complete, or asyncio.create_task() to schedule coroutines as tasks. For more control, use asyncio.as_completed() to process results as they become available. Always await the results and handle exceptions appropriately, as they may be raised from any of the concurrent tasks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is a list comprehension and when should I use it?",
    "answer": "List comprehensions provide a concise way to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations and filtering. Use them for straightforward operations, but avoid complex logic that makes them hard to read - in such cases, regular loops are clearer.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The algorithm has O(log n) time complexity and can be implemented recursively or iteratively using two pointers (left and right boundaries).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are the potential issues with using mutable default arguments in Python functions?",
    "answer": "Mutable default arguments (like lists or dictionaries) are created once when the function is defined, not each time it's called, leading to shared state between function calls. This causes unexpected behavior where modifications persist across calls. Instead, use None as the default and create the mutable object inside the function, or use immutable defaults. This is a common source of subtle bugs in Python code.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file reading, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle many concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have O(1) average time complexity due to hash table implementation. In the worst case (many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries extremely efficient for key-based lookups compared to lists which require O(n) time for searching.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's crashing?",
    "answer": "Start by reading the error traceback from bottom to top to identify the exact line and error type. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. Check for common issues like undefined variables, wrong data types, or index out of range errors.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' compares the values of two objects to see if they're equal, while 'is' checks if two variables reference the exact same object in memory. Use '==' for value comparison and 'is' for identity comparison, typically with None, True, False, or when you specifically need to check object identity.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making threading ineffective for CPU-bound tasks in Python. However, threading is still useful for I/O-bound tasks since the GIL is released during I/O operations. For CPU-bound parallelism, use multiprocessing instead of threading.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between asyncio.gather() and asyncio.wait()?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception if any coroutine fails. asyncio.wait() provides more control, returning done and pending sets, and allows you to specify when to return (first completion, first exception, or all completed). Use gather() for simple concurrent execution, wait() for more complex coordination.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I use list comprehensions instead of regular for loops?",
    "answer": "List comprehensions are more concise, readable, and often faster than equivalent for loops for creating lists. They express the intent more clearly and are generally considered more Pythonic. However, use regular loops for complex logic or when you need to perform multiple operations that don't result in a new list.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. This gives O(log n) time complexity, much faster than linear search's O(n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work under the hood?",
    "answer": "Decorators are functions that modify or extend other functions without permanently changing them. They work by taking a function as input and returning a modified version. Under the hood, @decorator syntax is syntactic sugar for func = decorator(func), leveraging Python's first-class functions and closures to wrap the original function's behavior.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Most IDEs also offer visual debuggers where you can set breakpoints and step through code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. It's particularly beneficial when you need to handle multiple concurrent operations, such as fetching data from multiple APIs simultaneously. However, avoid async/await for CPU-intensive tasks as it won't provide performance benefits.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's optimized hash function. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, and write docstrings for functions and classes. Keep functions small and focused on a single task, avoid deep nesting, and use meaningful comments for complex logic. Consider using type hints to make function signatures clearer and help catch errors early.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await' and 'asyncio.gather()' when handling multiple async operations?",
    "answer": "Using 'await' on multiple operations runs them sequentially, waiting for each to complete before starting the next. 'asyncio.gather()' runs multiple async operations concurrently and waits for all to complete, significantly improving performance. For example, 'await asyncio.gather(task1(), task2(), task3())' runs all three tasks simultaneously rather than one after another.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a simple implementation: 'def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left+right)//2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid+1; else: right = mid-1; return -1'",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's Global Interpreter Lock (GIL) implications for concurrent programming?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making threading ineffective for CPU-bound tasks. For I/O-bound tasks, threading still works because the GIL is released during I/O operations. For CPU-intensive work requiring parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except' clauses. Always handle the most specific exceptions first, then more general ones. Use 'finally' for cleanup code that must run regardless of whether an exception occurred. Consider using 'else' clause in try/except for code that should only run if no exception was raised.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python, and when would I use each?",
    "answer": "A shallow copy creates a new object but references to nested objects are shared with the original. A deep copy creates completely independent copies of all nested objects. Use shallow copy (copy.copy()) when you want to modify the top-level object but keep nested objects shared. Use deep copy (copy.deepcopy()) when you need completely independent objects, though it's more memory and time intensive.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are ideal for collections that may change size, while tuples are perfect for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "async/await is used for asynchronous programming to handle I/O-bound operations without blocking the main thread. You define async functions with 'async def' and call them with 'await'. Use async/await for operations like web requests, file I/O, or database queries where you're waiting for external resources, but not for CPU-intensive tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Searching in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash implementation is designed to minimize this. This makes dictionaries extremely efficient for lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why am I getting 'UnboundLocalError' when trying to modify a global variable inside a function?",
    "answer": "This error occurs when Python treats a variable as local because you're assigning to it inside the function, but you're trying to read it before assignment. To fix this, use the 'global' keyword before the variable name at the start of your function. Alternatively, consider passing the variable as a parameter and returning the modified value instead of using global variables.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collector work and when might I need to worry about memory management?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically freeing objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references. You typically don't need to manage memory manually, but be aware of circular references, large data structures, and long-running processes where memory leaks might accumulate over time.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables point to the exact same object in memory). Use '==' when comparing values and 'is' when checking if something is None or comparing with singleton objects. For example, 'a == b' compares content, but 'a is b' checks if they're the same object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a slow Python loop that processes large amounts of data?",
    "answer": "First, use profiling tools like cProfile to identify bottlenecks, then consider vectorization with NumPy, list comprehensions instead of loops, or moving computations outside loops. For I/O operations, use async/await or threading, and for CPU-intensive tasks, consider multiprocessing or libraries like Numba for JIT compilation. Sometimes the biggest gains come from algorithmic improvements rather than micro-optimizations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a deque instead of a list in Python?",
    "answer": "Use collections.deque when you frequently add or remove elements from both ends of the sequence, as deque provides O(1) operations for appendleft() and popleft(). Lists are O(n) for operations at the beginning because all elements must be shifted. Deques are ideal for implementing queues, sliding window algorithms, or any scenario requiring efficient operations at both ends.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except' clauses, and handle exceptions at the appropriate level in your code. Always catch the most specific exception types first, use 'finally' for cleanup code that must run regardless of exceptions, and consider 're-raising' exceptions with 'raise' if you can't fully handle them. Log errors appropriately and avoid silently ignoring exceptions.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create a decorator that measures function execution time?",
    "answer": "Decorators are functions that modify or extend other functions without changing their code directly, using the @decorator syntax. Here's a timing decorator: python\nimport time\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f'{func.__name__} took {time.time() - start:.4f} seconds')\n        return result\n    return wrapper Use it with @timer above any function definition.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples also use less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file reading, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. This allows your program to handle other tasks while waiting for slow operations to complete, improving performance in applications that deal with many concurrent operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a binary search tree?",
    "answer": "The average time complexity is O(log n) for a balanced BST, but it can degrade to O(n) in the worst case when the tree becomes skewed (essentially a linked list). This happens when elements are inserted in sorted order without balancing. Self-balancing trees like AVL or Red-Black trees maintain O(log n) complexity by automatically rebalancing.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python program that's giving me unexpected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Most IDEs also offer visual debuggers with breakpoints and step-through capabilities. Check your assumptions about data types and values at each step.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create one?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. Create one by defining a function that takes another function as an argument and returns a wrapper function. Use the @decorator_name syntax above the function you want to decorate. Common uses include logging, authentication, and timing function execution.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a thread-safe singleton pattern in Python?",
    "answer": "Use a lock mechanism with the threading module to ensure only one instance is created in multi-threaded environments. Implement double-checked locking: check if instance exists, acquire lock, check again, then create if needed. Alternatively, use a metaclass or the __new__ method with proper synchronization. Python's module system also naturally provides singleton behavior.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' compares the values of two objects for equality, while 'is' checks if two variables refer to the same object in memory. Use '==' when you want to check if contents are the same, and 'is' when checking object identity. The 'is' operator is commonly used with None: 'if x is None' rather than 'if x == None'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize this code that processes a large list?",
    "answer": "Consider using list comprehensions instead of loops for simple operations, as they're often faster. For very large datasets, use generators to process items lazily and save memory. Profile your code with cProfile to identify bottlenecks, and consider using NumPy for numerical operations or pandas for data manipulation, as they're optimized for performance.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between depth-first search (DFS) and breadth-first search (BFS)?",
    "answer": "DFS explores as far as possible along each branch before backtracking, using a stack (or recursion). BFS explores all neighbors at the current depth before moving to the next level, using a queue. DFS uses less memory but may not find the shortest path, while BFS guarantees the shortest path in unweighted graphs but uses more memory.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except:' clauses. Always catch the most specific exception first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions. Consider using 'else' clause for code that should only run if no exception occurred, and always log or handle exceptions appropriately rather than silently ignoring them.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be modified after creation) and uses square brackets [], while a tuple is immutable (cannot be changed after creation) and uses parentheses (). Lists are better for data that needs to change, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys because they're immutable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access a list index that doesn't exist. Add print statements to check the length of your list and the index you're trying to access. Use try-except blocks to catch the error and handle it gracefully, or add conditional checks like 'if index < len(my_list)' before accessing elements.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python and how does it work?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries that involve waiting. The 'async def' defines a coroutine function, and 'await' pauses execution until the awaited operation completes, allowing other code to run. This enables concurrent execution without the complexity of threading, making your program more efficient when dealing with multiple slow operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a dictionary versus a list?",
    "answer": "Searching in a dictionary (using keys) has O(1) average time complexity because it uses hash tables for direct access. Searching in a list has O(n) time complexity because you may need to check every element sequentially. This makes dictionaries much faster for lookups, especially with large datasets.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 for consistent formatting, use descriptive variable names, write docstrings for functions and classes, and keep functions small and focused on a single task. Always handle exceptions appropriately, avoid global variables when possible, and use list comprehensions for simple transformations. Comment your code to explain 'why' rather than 'what', and use virtual environments for project dependencies.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically freeing memory when an object's reference count reaches zero. It also has a cyclic garbage collector for circular references. Issues can arise with large objects, circular references in performance-critical code, or when interfacing with C extensions that don't properly manage references.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' operators in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables reference the same object in memory). Use '==' for comparing values and 'is' for comparing with None, True, False, or when you specifically need to check if two variables point to the same object.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. This gives O(log n) time complexity, much faster than linear search's O(n) for large datasets.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create a simple one?",
    "answer": "Decorators are functions that modify or enhance other functions without changing their code. They use the @ symbol and are commonly used for logging, authentication, or timing. A simple decorator wraps a function: 'def my_decorator(func): def wrapper(*args, **kwargs): # do something before; result = func(*args, **kwargs); # do something after; return result; return wrapper'.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why am I getting a 'RecursionError: maximum recursion depth exceeded' and how do I fix it?",
    "answer": "This error occurs when a recursive function calls itself too many times without a proper base case or the base case is never reached. Check that your recursive function has a clear stopping condition and that each recursive call moves closer to that condition. You can also increase the recursion limit with sys.setrecursionlimit(), but it's better to fix the logic or use iteration instead.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples also use less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing with no clear error message?",
    "answer": "Start by adding print statements or using the Python debugger (pdb) to trace execution flow. Check for common issues like undefined variables, type mismatches, or file path problems. Use try-except blocks to catch and display specific exceptions, and consider running your script with python -u to see unbuffered output immediately.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when dealing with I/O-bound operations like network requests, file operations, or database queries that involve waiting. It allows other code to run while waiting for these operations to complete, improving performance in applications that handle many concurrent operations. Don't use it for CPU-intensive tasks, as it won't provide benefits there.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 for code formatting, use descriptive variable and function names, and keep functions small and focused on a single task. Write docstrings for functions and classes, handle exceptions appropriately, and use virtual environments for project dependencies. Also, avoid global variables and prefer list comprehensions over loops when they improve readability.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does this list comprehension work: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This creates a list of squared even numbers from 0 to 9. It iterates through range(10) (0-9), filters for even numbers with 'if x % 2 == 0', then squares each even number with 'x**2'. The result is [0, 4, 16, 36, 64] - the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity difference between searching in a list vs a set?",
    "answer": "Searching in a list has O(n) time complexity because it must check each element sequentially until found. Searching in a set has O(1) average time complexity because sets use hash tables for constant-time lookups. For frequent lookups with large datasets, converting a list to a set first can dramatically improve performance.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle multiple async operations that depend on each other?",
    "answer": "Use 'await' for sequential dependencies where one result is needed for the next operation. For independent operations, use 'asyncio.gather()' or 'asyncio.create_task()' to run them concurrently. For complex workflows, consider using 'asyncio.as_completed()' to process results as they become available, or chain operations with proper error handling using try-except blocks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why am I getting 'UnboundLocalError' when trying to modify a global variable inside a function?",
    "answer": "This happens when Python sees an assignment to a variable inside a function and treats it as local, even if you're trying to read it first. Use the 'global' keyword before the variable name inside your function to explicitly declare it as global. Alternatively, consider passing the variable as a parameter and returning the modified value instead of using globals.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to implement a queue data structure in Python?",
    "answer": "Use 'collections.deque' for the most efficient queue implementation, as it provides O(1) append and pop operations from both ends. Regular lists are inefficient for queues because popping from the front requires shifting all remaining elements (O(n) complexity). For thread-safe queues, use 'queue.Queue' from the standard library.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I find and fix memory leaks in my Python application?",
    "answer": "Use memory profilers like 'memory_profiler' or 'tracemalloc' to identify where memory usage grows unexpectedly. Common causes include circular references, unclosed files/connections, global variables accumulating data, or keeping references to large objects. Use weak references when appropriate, ensure proper cleanup in finally blocks, and consider using context managers (with statements) for resource management.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for data that needs to be modified, while tuples are good for data that should remain constant. For example: my_list = [1, 2, 3] can be changed, but my_tuple = (1, 2, 3) cannot be modified.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an unexpected error?",
    "answer": "Start by reading the error message carefully - it tells you the error type and line number. Use print statements to check variable values at different points, or use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' before the problematic line. Many IDEs also offer visual debugging tools with breakpoints and variable inspection.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does async/await do in Python and when should I use it?",
    "answer": "Async/await enables asynchronous programming, allowing your program to handle other tasks while waiting for slow operations like network requests or file I/O. Use 'async def' to define an asynchronous function and 'await' to pause execution until an async operation completes. This is particularly useful for web scraping, API calls, or any application that needs to handle multiple concurrent operations efficiently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 for code formatting, use descriptive variable and function names, and write docstrings for your functions. Keep functions small and focused on a single task, handle exceptions appropriately with try/except blocks, and avoid global variables when possible. Also, use virtual environments for project dependencies and write unit tests for your code.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does a dictionary work internally in Python?",
    "answer": "Python dictionaries use hash tables for fast key-value lookups with average O(1) time complexity. When you store a key-value pair, Python computes a hash of the key to determine where to store the value in memory. This allows for very fast retrieval, insertion, and deletion operations, making dictionaries ideal for cases where you need quick access to data by a unique identifier.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value, while 'is' checks if two variables refer to the exact same object in memory. For example, two lists with identical contents will be equal with '==' but not with 'is' unless they're the same object. Use '==' for value comparison and 'is' for identity comparison, particularly when checking against None or boolean values.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element - if equal, you found it; if target is smaller, search the left half; if larger, search the right half. Here's a simple implementation: def binary_search(arr, target): left, right = 0, len(arr) - 1; while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1; return -1. Time complexity is O(log n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create one?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently changing them. They use the @ syntax and are commonly used for logging, timing, or authentication. To create a basic decorator: def my_decorator(func): def wrapper(*args, **kwargs): print('Before function call'); result = func(*args, **kwargs); print('After function call'); return result; return wrapper. Then use @my_decorator above any function definition.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I optimize my Python code for better performance?",
    "answer": "Profile your code first using tools like cProfile to identify bottlenecks, then focus optimization efforts there. Use built-in functions and libraries (like NumPy for numerical operations), avoid nested loops when possible, and consider list comprehensions over traditional loops. For CPU-intensive tasks, consider using multiprocessing, and for I/O-bound tasks, use asyncio or threading. Also, use appropriate data structures - sets for membership testing, deques for frequent insertions/deletions at both ends.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates completely independent copies of nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster and sufficient when you don't have nested mutable objects, but deep copy is necessary when you need complete independence between the original and copied data structures.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're immutable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle many concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a dictionary versus a list?",
    "answer": "Searching in a dictionary is O(1) average case because it uses hash tables, while searching in a list is O(n) because you might need to check every element. This means dictionary lookups are much faster for large datasets. However, dictionaries use more memory and don't maintain insertion order in older Python versions.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's crashing?",
    "answer": "Start by reading the error message and traceback to identify where the crash occurs. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. Check for common issues like IndexError, KeyError, or None values where you expect data. The traceback shows the exact line and call stack leading to the error.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' compares the values of objects to see if they're equal, while 'is' checks if two variables point to the exact same object in memory. Use '==' for value comparison and 'is' only for identity comparison (like checking if something is None). For example, two lists with identical contents are == but not 'is'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple Python threads from executing bytecode simultaneously, making threading ineffective for CPU-bound tasks. However, threading still helps with I/O-bound tasks because the GIL is released during I/O operations. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to remove duplicates from a list while preserving order?",
    "answer": "Use dict.fromkeys() for Python 3.7+ since dictionaries maintain insertion order: list(dict.fromkeys(my_list)). For older versions, use a set to track seen items: [x for i, x in enumerate(my_list) if x not in my_list[:i]]. The dict.fromkeys() method is both readable and efficient with O(n) time complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except:' clauses. Always catch the most specific exception types first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions, and 'else' for code that should only run if no exception occurred.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between depth-first search (DFS) and breadth-first search (BFS)?",
    "answer": "DFS explores as far as possible along each branch before backtracking, using a stack (or recursion). BFS explores all neighbors at the current depth before moving to the next level, using a queue. DFS uses less memory but may not find the shortest path, while BFS guarantees the shortest path in unweighted graphs but uses more memory.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use list comprehensions versus regular for loops in Python?",
    "answer": "Use list comprehensions for simple transformations that create new lists, as they're more concise and often faster. Use regular for loops for complex logic, multiple statements, or when you don't need to create a new list. List comprehensions are great for filtering and mapping operations but can become unreadable with too much complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for data that shouldn't change, like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure you're handling edge cases correctly. Modern IDEs also provide visual debuggers that let you set breakpoints and inspect variables.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular synchronous code?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that involve waiting. Async is beneficial when you need to handle multiple concurrent operations without blocking the main thread. However, avoid async for CPU-intensive tasks as it won't provide performance benefits and adds complexity. If your program is simple and doesn't involve waiting for external resources, stick with synchronous code.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to their hash table implementation. In the worst case (when there are many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries extremely efficient for key-based lookups compared to lists, which have O(n) search time. The constant-time lookup is why dictionaries are preferred for caching and mapping operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I avoid the common mistake of using mutable default arguments in Python functions?",
    "answer": "Never use mutable objects like lists or dictionaries as default arguments because they're created once when the function is defined, not each time it's called. Instead, use None as the default and create the mutable object inside the function: 'def func(items=None): if items is None: items = []'. This ensures each function call gets a fresh, independent mutable object. This is one of Python's most common gotchas for beginners.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does the 'await' keyword do in an async function?",
    "answer": "The 'await' keyword pauses the execution of an async function until the awaited operation completes, allowing other code to run in the meantime. It can only be used inside async functions and with awaitable objects like coroutines, tasks, or futures. When you await something, control is returned to the event loop, which can then execute other pending tasks. This enables concurrent execution without blocking the entire program.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a custom iterator in Python?",
    "answer": "Create a class that implements both '__iter__()' and '__next__()' methods. The '__iter__()' method should return self, and '__next__()' should return the next item or raise StopIteration when done. For example, a simple counter iterator would track the current value in '__next__()', increment it, and return the previous value. You can also use generators with 'yield' as a simpler alternative to creating custom iterator classes.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables reference the same object in memory). Use '==' when comparing values and 'is' when checking if two variables point to the exact same object. The most common use of 'is' is comparing with None: 'if x is None'. For small integers and strings, Python may reuse objects, making 'is' sometimes work like '==', but don't rely on this behavior.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a function that's running too slowly on large datasets?",
    "answer": "First, profile your code using tools like cProfile to identify bottlenecks. Consider algorithmic improvements like using more efficient data structures (dict instead of list for lookups, set for membership tests). Use built-in functions and libraries like NumPy for numerical operations, as they're implemented in C. Cache expensive computations with functools.lru_cache, and consider vectorized operations or parallel processing with multiprocessing for CPU-bound tasks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the proper way to handle exceptions without hiding errors?",
    "answer": "Use specific exception types instead of bare 'except:' clauses, and only catch exceptions you can meaningfully handle. Always include proper logging or re-raising when necessary: 'except ValueError as e: logger.error(f\"Invalid input: {e}\"); raise'. Avoid catching Exception unless you re-raise it after cleanup. Use try/except/else/finally appropriately: 'else' for code that should run only if no exception occurred, 'finally' for cleanup that must always happen.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for data that shouldn't change, like coordinates or database records.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "async/await is used for asynchronous programming to handle I/O-bound operations without blocking the program. Define functions with 'async def' and use 'await' for asynchronous operations like network requests or file I/O. This allows other code to run while waiting for slow operations to complete, improving performance for concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this error mean: 'IndexError: list index out of range'?",
    "answer": "This error occurs when you try to access a list element at an index that doesn't exist. For example, accessing index 5 in a list with only 3 elements (indices 0, 1, 2). Always check the list length with len() or use try/except blocks to handle this gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of searching in a hash table versus a binary search tree?",
    "answer": "Hash tables have O(1) average time complexity for search operations, but O(n) worst case when many collisions occur. Binary search trees have O(log n) average case for balanced trees, but can degrade to O(n) for unbalanced trees. Hash tables are generally faster for simple key lookups, while BSTs maintain sorted order.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's running slowly?",
    "answer": "Use profiling tools like cProfile to identify bottlenecks: 'python -m cProfile -s cumulative your_script.py'. Look for functions with high cumulative time or many calls. You can also add timing statements with time.time() around suspicious code blocks, or use line_profiler for line-by-line analysis.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 for style guidelines, use descriptive variable names, keep functions small and focused on one task, and add docstrings to functions and classes. Use list comprehensions when appropriate, handle exceptions properly with try/except, and avoid global variables when possible.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between await asyncio.gather() and await asyncio.wait()?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception if any fails. asyncio.wait() provides more control, returning done and pending sets, and allows you to specify when to return (first completed, first exception, or all completed). Use gather() for simple concurrent execution, wait() for complex coordination.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How does a stack data structure work and what are common use cases?",
    "answer": "A stack follows Last-In-First-Out (LIFO) principle with push() to add and pop() to remove elements from the top. Common uses include function call management, undo operations, expression evaluation, and backtracking algorithms. In Python, you can use a list with append() and pop() methods to implement a stack.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between merge sort and quicksort algorithms?",
    "answer": "Merge sort has guaranteed O(n log n) time complexity and is stable, but uses O(n) extra space for merging. Quicksort has O(n log n) average case but O(n\u00b2) worst case, uses O(log n) space, and is typically faster in practice. Choose merge sort for guaranteed performance and stability, quicksort for average-case speed.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I handle race conditions when using asyncio with shared resources?",
    "answer": "Use asyncio.Lock() to protect shared resources from concurrent access. Wrap critical sections with 'async with lock:' to ensure only one coroutine accesses the resource at a time. For more complex scenarios, consider asyncio.Semaphore() for limiting concurrent access or asyncio.Queue() for safe data passing between coroutines.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable, meaning you can change, add, or remove elements after creation, while a tuple is immutable and cannot be modified once created. Lists are defined with square brackets [] and tuples with parentheses (). Use lists when you need to modify the data and tuples when you want to ensure the data remains constant.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback carefully to identify the line where the error occurs and the exception type. Use print statements or the Python debugger (pdb) to inspect variable values at different points in your code. You can also wrap suspicious code in try-except blocks to handle specific exceptions gracefully and get more information about what went wrong.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async programming allows other code to run while waiting for these operations to complete, improving performance for I/O-bound tasks. However, it's not beneficial for CPU-intensive tasks and adds complexity to your code structure.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Searching in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case scenario (when many hash collisions occur), it can degrade to O(n), but this is extremely rare with Python's hash function. This makes dictionaries excellent for fast lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python code?",
    "answer": "Use try-except blocks to catch specific exceptions rather than generic ones, and avoid bare except clauses. Always clean up resources using finally blocks or context managers (with statements). Log exceptions appropriately and only catch exceptions you can meaningfully handle - let others propagate up to be handled at the appropriate level.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), squares each even number (x**2), and collects the results in a list. The final result would be [0, 4, 16, 36, 64], representing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a Python function that's running slowly?",
    "answer": "First, profile your code using tools like cProfile to identify bottlenecks. Common optimizations include using built-in functions instead of loops, choosing appropriate data structures (sets for membership testing, dictionaries for lookups), avoiding repeated expensive operations, and using list comprehensions instead of append() in loops. For CPU-intensive tasks, consider using NumPy or moving critical sections to C extensions.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await asyncio.sleep()` and `time.sleep()` in async functions?",
    "answer": "`await asyncio.sleep()` is non-blocking and allows other coroutines to run during the sleep period, while `time.sleep()` blocks the entire event loop and prevents any other async operations from executing. Always use `asyncio.sleep()` in async functions to maintain the benefits of asynchronous programming. Using `time.sleep()` in async code defeats the purpose of async/await.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a basic implementation: `def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left+right)//2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid+1; else: right = mid-1; return -1`",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions and why are they important?",
    "answer": "Python follows PEP 8 conventions: use snake_case for variables and functions, PascalCase for classes, UPPER_CASE for constants, and prefix private attributes with underscore. Good naming makes code self-documenting and easier to maintain. Consistent naming conventions help other developers (including your future self) understand the code's purpose and structure quickly.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like file reading, network requests, or database queries. Define functions with 'async def' and use 'await' before asynchronous operations. This allows your program to handle other tasks while waiting for slow operations to complete, improving overall performance. You'll need to run async functions using asyncio.run() or within an existing event loop.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize this. This makes dictionaries extremely efficient for key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's not working as expected?",
    "answer": "Start by using print statements to trace variable values and program flow, then consider using Python's built-in debugger (pdb) with pdb.set_trace() for interactive debugging. Check error messages carefully as they often point to the exact issue and line number. Use an IDE with debugging features or add logging statements to understand what's happening during execution.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables point to the exact same object in memory). Use '==' for comparing values and 'is' for comparing with None, True, False, or when you specifically need to check object identity. For example, [1,2] == [1,2] is True, but [1,2] is [1,2] is False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. This gives O(log n) time complexity, much faster than linear search's O(n). Here's a simple implementation: def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left+right)//2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid+1; else: right = mid-1; return -1",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions and why are they important?",
    "answer": "Follow PEP 8: use snake_case for variables and functions, PascalCase for classes, and UPPER_CASE for constants. Private attributes should start with underscore, and very private ones with double underscore. Good naming conventions make code more readable, maintainable, and help other developers (including your future self) understand the code's purpose quickly.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle race conditions when using asyncio with shared resources?",
    "answer": "Use asyncio.Lock() to protect shared resources from concurrent access, similar to threading locks but for async code. Wrap critical sections with 'async with lock:' to ensure only one coroutine accesses the resource at a time. For more complex scenarios, consider using asyncio.Queue for producer-consumer patterns or asyncio.Semaphore to limit concurrent access to a specific number of coroutines.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster and sufficient when you only need to modify the top-level container, but deep copy is necessary when nested objects might be modified independently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I optimize the performance of a Python function that processes large datasets?",
    "answer": "Profile your code first using cProfile to identify bottlenecks, then consider using NumPy for numerical operations, list comprehensions instead of loops, and built-in functions like map() or filter(). For CPU-intensive tasks, consider multiprocessing, and for I/O-bound operations, use asyncio. Sometimes algorithmic improvements (better data structures or algorithms) provide the biggest performance gains.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections of items. For example, [1, 2, 3] is a list and (1, 2, 3) is a tuple.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing with a KeyError?",
    "answer": "A KeyError occurs when trying to access a dictionary key that doesn't exist. Use try/except blocks to handle missing keys gracefully, or use the .get() method with a default value. You can also print the dictionary keys with dict.keys() to verify what's available before accessing them.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources. It allows other code to run while waiting, improving performance in applications that handle many concurrent operations. Don't use it for CPU-intensive tasks as it won't provide benefits there.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst-case scenario (many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python without hiding bugs?",
    "answer": "Use specific exception types instead of bare 'except' clauses, and only catch exceptions you can meaningfully handle. Always log exceptions or re-raise them after handling, and use 'finally' blocks for cleanup code. For example, catch 'FileNotFoundError' specifically rather than all exceptions, so programming errors aren't accidentally suppressed.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result is [0, 4, 16, 36, 64] representing squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's GIL affect async/await performance?",
    "answer": "The Global Interpreter Lock (GIL) prevents true parallelism for CPU-bound tasks, but async/await is designed for I/O-bound operations where the GIL is released during I/O waits. This means async/await can still provide significant performance benefits for network requests, file operations, and database queries. For CPU-bound parallelism, use multiprocessing instead of async/await.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between __str__ and __repr__ methods in Python classes?",
    "answer": "__str__ should return a human-readable string representation for end users, while __repr__ should return an unambiguous string that ideally could recreate the object. __repr__ is used in debugging and when objects are in containers, while __str__ is used by print() and str(). If only one is defined, __repr__ serves as the fallback for both.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I efficiently find duplicates in a large Python list?",
    "answer": "Use a set to track seen elements while iterating through the list once, giving O(n) time complexity. For example: seen = set(); duplicates = set(); for item in my_list: (duplicates.add(item) if item in seen else seen.add(item)). Alternatively, use collections.Counter for counting occurrences, then filter items with count > 1.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What happens when you await multiple coroutines sequentially vs using asyncio.gather()?",
    "answer": "Sequential awaiting (await cor1; await cor2) runs coroutines one after another, taking the sum of their execution times. asyncio.gather() runs them concurrently, completing in roughly the time of the slowest coroutine. Use gather() when coroutines are independent and can run simultaneously, but sequential await when later coroutines depend on earlier results.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better when you need to modify data, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside another async function. This allows other code to run while waiting for slow operations to complete, making your program more efficient for concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "My Python code is running slowly. What are some common debugging techniques to identify bottlenecks?",
    "answer": "Use the cProfile module to profile your code and identify slow functions, or add timing with time.time() around suspicious code blocks. Check for unnecessary loops, especially nested ones, and look for repeated expensive operations that could be cached. The line_profiler tool can also show you exactly which lines are taking the most time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a list of squared even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), squares each even number (x**2), and creates a new list with the results. The final result would be [0, 4, 16, 36, 64].",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations in Python are generally O(1) average case due to hash table implementation. Lookups, insertions, and deletions are O(1) on average, but can degrade to O(n) in worst-case scenarios with many hash collisions. Iterating through all keys/values is O(n) where n is the number of items.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a deque instead of a list in Python?",
    "answer": "Use collections.deque when you frequently add or remove items from both ends of the sequence. Deques have O(1) append and pop operations on both ends, while lists have O(n) for operations at the beginning. Deques are perfect for implementing queues, sliding windows, or when you need efficient operations on both ends.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare except clauses. Always catch the most specific exception types first, and consider using finally blocks for cleanup code. It's better to catch ValueError or FileNotFoundError specifically rather than using a generic Exception, as this makes debugging easier and prevents hiding unexpected errors.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between asyncio.gather() and asyncio.create_task()?",
    "answer": "asyncio.create_task() schedules a single coroutine to run concurrently and returns a Task object you can await later. asyncio.gather() runs multiple coroutines concurrently and waits for all of them to complete, returning their results as a list. Use create_task() for fire-and-forget operations or when you need fine control, and gather() when you need all results together.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 for consistent formatting, use descriptive variable and function names, and write docstrings for functions and classes. Keep functions small and focused on single responsibilities, avoid deep nesting, and use list comprehensions judiciously (not for complex logic). Also, handle exceptions appropriately and use type hints in modern Python to improve code clarity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multi-threading performance?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making CPU-bound multi-threading ineffective in Python. However, I/O-bound operations release the GIL, so threading can still improve performance for tasks like file operations or network requests. For CPU-bound tasks requiring true parallelism, use multiprocessing instead of threading to bypass the GIL limitation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are ideal when you need to modify data, whereas tuples are better for fixed collections like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I fix a 'list index out of range' error?",
    "answer": "This error occurs when you try to access a list index that doesn't exist. Check that your index is within the valid range (0 to len(list)-1 for positive indices). You can use len() to verify list size, add bounds checking with if statements, or use try/except blocks to handle the IndexError gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like file reading, network requests, or database queries that would otherwise block execution. It's particularly beneficial when you need to handle multiple concurrent operations efficiently. However, avoid it for CPU-intensive tasks where threading or multiprocessing would be more appropriate.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst-case scenario (when many hash collisions occur), it can degrade to O(n), but this is extremely rare in practice. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare except clauses. Place only the code that might raise an exception in the try block, handle expected exceptions explicitly, and use finally for cleanup code. Consider using else for code that should run only if no exceptions occurred, and always log or handle exceptions appropriately rather than silently ignoring them.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using the condition `x % 2 == 0`, then squares each even number with `x**2`. The result will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I avoid race conditions when using async/await with shared data?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Event() to coordinate access to shared resources. Always acquire locks before modifying shared data and use async context managers (async with) to ensure proper cleanup. Consider using asyncio.Queue for producer-consumer patterns or immutable data structures when possible to minimize synchronization needs.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between == and is in Python?",
    "answer": "The == operator checks for value equality (whether two objects have the same content), while is checks for identity (whether two variables reference the same object in memory). Use == when comparing values and is when checking for None, True, False, or when you specifically need to verify object identity. For example, `[1,2,3] == [1,2,3]` is True, but `[1,2,3] is [1,2,3]` is False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a efficient solution for finding duplicates in a large list?",
    "answer": "Use a set to track seen elements while iterating through the list once, achieving O(n) time complexity. Create an empty set, iterate through the list, and for each element check if it's already in the set - if yes, it's a duplicate; if no, add it to the set. This approach is much more efficient than nested loops O(n\u00b2) and works well even with millions of elements.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I profile and optimize CPU-bound async functions that are blocking the event loop?",
    "answer": "Use asyncio event loop monitoring with `asyncio.get_event_loop().slow_callback_duration` and profiling tools like cProfile or py-spy to identify blocking operations. Move CPU-intensive work to thread pools using `asyncio.get_event_loop().run_in_executor()` or process pools for true parallelism. Consider breaking large computations into smaller chunks with periodic `await asyncio.sleep(0)` calls to yield control back to the event loop.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are ideal when you need to modify data, while tuples are better for fixed collections like coordinates or database records. Tuples also have slightly better performance and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle multiple concurrent tasks like web servers or API clients.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the best way to debug a Python program that's crashing?",
    "answer": "Start by reading the full error traceback from bottom to top to identify the exact line and error type. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. Consider using an IDE with debugging features or logging instead of print statements for larger applications. Always test with simple inputs first before moving to complex scenarios.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of different dictionary operations in Python?",
    "answer": "Dictionary operations in Python have average O(1) time complexity for get, set, and delete operations due to hash table implementation. However, in worst-case scenarios with many hash collisions, these operations can degrade to O(n). Iteration over all keys/values is O(n) where n is the number of items in the dictionary.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you implement a binary search algorithm in Python?",
    "answer": "Binary search repeatedly divides a sorted array in half, comparing the target with the middle element. If the target is smaller, search the left half; if larger, search the right half. This continues until the target is found or the search space is empty, achieving O(log n) time complexity compared to O(n) for linear search.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions and why are they important?",
    "answer": "Follow PEP 8: use snake_case for variables and functions, PascalCase for classes, and UPPER_CASE for constants. Use descriptive names that clearly indicate purpose rather than abbreviations. Good naming conventions make code self-documenting, easier to maintain, and help other developers (including future you) understand the code's intent quickly.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collector work and when might you need to consider it?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically deleting objects when no references remain. It also has a cyclic garbage collector for handling circular references between objects. You might need to consider garbage collection when dealing with large datasets, circular references, or performance-critical applications where you need to manually trigger collection with gc.collect().",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'==' checks if two objects have the same value (calls __eq__ method), while 'is' checks if two variables reference the exact same object in memory. Use '==' for value comparison and 'is' for identity comparison, typically with None, True, False, or when you specifically need to check if two variables point to the same object. For example, 'x is None' is preferred over 'x == None'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do you handle race conditions when using asyncio in Python?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Queue() to coordinate access to shared resources. Locks ensure only one coroutine can access a critical section at a time, while semaphores limit the number of concurrent accesses. Always use 'async with' syntax with these primitives to ensure proper cleanup, and be careful about the order of acquiring multiple locks to avoid deadlocks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is a generator in Python and why would I use one?",
    "answer": "A generator is a function that uses 'yield' instead of 'return' to produce values lazily, one at a time, rather than creating all values in memory at once. Generators are memory-efficient for large datasets and can represent infinite sequences. They're perfect for processing large files, streaming data, or any scenario where you don't need all values simultaneously, like reading CSV files line by line.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are good for collections that need to be modified, while tuples are better for fixed data like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's running slowly?",
    "answer": "Start by using a profiler like cProfile to identify bottlenecks in your code. Add timing statements around suspicious sections using time.time() or the timeit module. Check for inefficient loops, unnecessary file I/O, or database queries that could be optimized. Consider using debugging tools like pdb to step through your code line by line.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program does a lot of I/O operations like web requests, file operations, or database queries that involve waiting. It's particularly useful for web scraping, API calls, or handling multiple concurrent connections. Don't use it for CPU-intensive tasks as it won't provide performance benefits there.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case scenario (when there are many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries very efficient for key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than catching all exceptions with bare 'except'. Always catch the most specific exception first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions, and consider using 'else' for code that should only run if no exceptions occurred.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks if two variables refer to the same object in memory (identity), while '==' checks if the values are equal (equality). For example, two different lists with the same contents will be equal (==) but not identical (is). Use 'is' for comparing with None, True, or False, and '==' for comparing values.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I make my async function handle multiple tasks concurrently?",
    "answer": "Use asyncio.gather() to run multiple coroutines concurrently and wait for all to complete, or asyncio.create_task() to schedule individual coroutines. For more control, use asyncio.as_completed() to process results as they finish. Always use 'await' when calling async functions to ensure proper execution.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions are a concise way to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations. Use them for straightforward operations, but avoid them if the logic becomes too complex as regular loops might be clearer.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n), making it much faster than linear search for large datasets.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work internally?",
    "answer": "Decorators are functions that modify or wrap other functions using the @ syntax. They work by taking a function as input and returning a modified version. Python internally replaces the decorated function with the decorator's return value. Common uses include logging, timing, authentication, and caching functionality.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for data that needs to be modified, while tuples are good for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that would otherwise block your program. Async code allows other tasks to run while waiting for these operations to complete, improving overall performance. It's particularly useful for web servers, API clients, or any application that needs to handle multiple concurrent operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify where the error occurred and what type of exception it is. Add print statements or use the Python debugger (pdb) to inspect variable values at different points. You can also use try/except blocks to catch specific exceptions and handle them gracefully while logging useful information.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (when there are many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small and focused on a single task. Always handle exceptions appropriately, use list comprehensions when they improve readability, and include docstrings for functions and classes. Additionally, avoid global variables and prefer explicit imports over wildcard imports.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector for handling reference cycles between objects. Issues can arise with circular references in large applications or when integrating with C extensions that don't properly manage reference counts, potentially causing memory leaks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between asyncio.gather() and asyncio.as_completed()?",
    "answer": "asyncio.gather() waits for all coroutines to complete and returns results in the same order as the input, making it ideal when you need all results together. asyncio.as_completed() returns an iterator that yields coroutines as they complete (in completion order), which is better when you want to process results as soon as they're available. Use gather() for batch processing and as_completed() for streaming results.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the key: maintain left and right pointers, calculate mid = (left + right) // 2, and update the pointers based on comparison until left > right.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does the 'with' statement do in Python?",
    "answer": "The 'with' statement is used for context management, ensuring that setup and cleanup operations happen automatically. It's commonly used for file operations where it guarantees the file is closed even if an exception occurs. The object used with 'with' must implement __enter__ and __exit__ methods, making it perfect for resource management like database connections, locks, or temporary state changes.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize the performance of a recursive function that has overlapping subproblems?",
    "answer": "Use memoization to cache results of expensive function calls, either with a dictionary or Python's @functools.lru_cache decorator. This prevents recalculating the same subproblems multiple times, converting exponential time complexity to polynomial in many cases. For even better performance, consider converting to an iterative bottom-up dynamic programming solution that builds up from the smallest subproblems.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries. Define async functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle multiple concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "My Python code is running slowly. What are some debugging techniques to find bottlenecks?",
    "answer": "Use the built-in 'cProfile' module to profile your code and identify slow functions: python -m cProfile your_script.py. For line-by-line analysis, use 'line_profiler' or add timing statements around suspected slow sections. Also check if you're using inefficient algorithms, unnecessary loops, or missing database indexes if working with databases.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is Big O notation and why does it matter?",
    "answer": "Big O notation describes how an algorithm's performance scales with input size, focusing on worst-case scenarios. O(1) is constant time, O(n) is linear, O(n\u00b2) is quadratic, etc. It matters because it helps you choose efficient algorithms and predict how your code will perform as data grows, preventing performance issues in production.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python without catching everything?",
    "answer": "Catch specific exceptions rather than using bare 'except:' clauses, and only catch exceptions you can meaningfully handle. Use 'try/except/else/finally' appropriately: 'else' runs when no exception occurs, 'finally' always runs for cleanup. Let unexpected exceptions propagate up so they can be logged and debugged properly.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value (calls the __eq__ method), while 'is' checks if they are the exact same object in memory. Use '==' for comparing values and 'is' for comparing with None, True, False, or when you specifically need to check object identity. For example: [1,2] == [1,2] is True, but [1,2] is [1,2] is False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Time complexity is O(log n). Here's the key insight: maintain left and right pointers, calculate mid = (left + right) // 2, and update the pointers based on comparison.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions provide a concise way to create lists: [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations and filtering. Use them for straightforward operations, but prefer regular loops for complex logic or when you need multiple statements per iteration.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I avoid race conditions when using asyncio with shared state?",
    "answer": "Use asyncio.Lock() to protect critical sections where shared state is modified, ensuring only one coroutine can access it at a time. For simple counters, consider using atomic operations or asyncio.Queue for communication between coroutines. Always acquire locks using 'async with lock:' syntax to ensure proper cleanup, and be careful about lock ordering to prevent deadlocks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but inserts references to objects in the original, while deep copy creates completely independent copies of nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster but changes to nested mutable objects affect both copies; deep copy is slower but provides complete independence.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to grow or shrink, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries. Define async functions with 'async def' and call them with 'await' inside other async functions. This allows your program to handle other tasks while waiting for slow operations to complete, improving performance in applications that deal with many concurrent operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations like get, set, and delete are O(1) average case due to hash table implementation, but O(n) worst case when hash collisions occur. Iterating through all keys/values is O(n) where n is the number of items. Dictionary lookups are much faster than list searches, making them ideal for key-value mappings and membership testing.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python program that's not working as expected?",
    "answer": "Start with print statements to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at breakpoints. Check error messages carefully - they usually point to the exact line and issue. Consider using an IDE with debugging features or tools like logging for more complex applications.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between '__str__' and '__repr__' methods in Python classes?",
    "answer": "__str__ should return a human-readable string representation for end users, while __repr__ should return an unambiguous string representation for developers, ideally showing how to recreate the object. If only one is defined, __str__ falls back to __repr__. A good __repr__ should be detailed enough that eval(repr(obj)) recreates the object when possible.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare 'except' clauses. Always catch the most specific exception types first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions. Consider using 'else' clause for code that should only run if no exceptions occurred in the try block.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying their code. They use the @ symbol and work by taking a function as input and returning a modified version. Common uses include logging, timing, authentication, and caching. They're essentially syntactic sugar for higher-order functions.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a set vs a list in Python?",
    "answer": "Use sets when you need unique elements and fast membership testing (O(1) average case), or when performing set operations like union, intersection, or difference. Use lists when you need ordered data, allow duplicates, or require indexing. Sets are unordered and don't support indexing, but they excel at removing duplicates and checking if items exist.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python code simultaneously, making threading ineffective for CPU-bound tasks in Python. However, threading still works well for I/O-bound operations since the GIL is released during I/O calls. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks if two variables reference the same object in memory (identity), while '==' checks if the values are equal (equality). Use 'is' for comparing with None, True, False, or when you specifically need to check object identity. Use '==' for comparing values. For example, two lists with same contents are equal (==) but not identical (is) unless they're the same object.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are good for collections that might change, like a shopping cart, while tuples are perfect for fixed data like coordinates (x, y). Lists have methods like append() and remove(), but tuples have fewer methods since they can't be modified.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's running but not giving the expected output?",
    "answer": "Start by adding print statements at key points to see what values your variables have during execution. Use the built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and make sure you're not making common mistakes like off-by-one errors in loops.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program does I/O operations like web requests, file operations, or database queries that involve waiting. It's particularly useful when you need to handle multiple operations concurrently without blocking the entire program. For CPU-intensive tasks that don't involve waiting, regular synchronous code or threading/multiprocessing might be better choices.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and write docstrings for your functions. Keep functions small and focused on a single task, avoid deep nesting with early returns, and add comments for complex logic. Use type hints to make your code self-documenting and consider using tools like Black for automatic formatting.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await asyncio.gather()' and 'await asyncio.wait()'?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception immediately if any task fails. asyncio.wait() gives you more control over completion conditions and returns two sets: done and pending tasks, allowing you to handle partial completions and errors more granularly. Use gather() for simple concurrent execution, wait() when you need fine-grained control over task completion.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the key: maintain left and right pointers, calculate mid = (left + right) // 2, and update pointers based on comparison until found or left > right.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why am I getting a 'RuntimeError: cannot be called from a running event loop' error?",
    "answer": "This error occurs when you try to use asyncio.run() inside an already running event loop, such as in Jupyter notebooks or some web frameworks. Instead of asyncio.run(), use 'await' if you're already in an async function, or create a task with asyncio.create_task(). In Jupyter, you can often just use 'await' directly without asyncio.run().",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to remove duplicates from a list while preserving order?",
    "answer": "Use a combination of a set for O(1) lookups and a list to maintain order: create an empty set to track seen items and a result list, then iterate through the original list, adding items to the result only if not in the seen set. This gives you O(n) time complexity. Alternatively, you can use dict.fromkeys(list) which preserves order and removes duplicates in one line.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in async functions without breaking the event loop?",
    "answer": "Wrap your async operations in try-except blocks just like synchronous code, but be careful with asyncio.gather() which cancels all tasks if one fails. Use asyncio.TaskGroup (Python 3.11+) or asyncio.as_completed() for better error handling across multiple tasks. Always await your async calls within try blocks, and consider using asyncio.create_task() with proper exception handling for fire-and-forget operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are good for collections that need to be modified, while tuples are better for fixed data like coordinates or database records. Tuples also use less memory and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like API calls, file reading, or database queries that would otherwise block your program. It allows other code to run while waiting for these operations to complete, improving performance in concurrent scenarios. However, avoid async/await for CPU-bound tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure your conditions and loops are working as expected.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Searching in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using 'except:' without specifying the exception type?",
    "answer": "Using bare 'except:' catches ALL exceptions, including system exits and keyboard interrupts, making debugging difficult and potentially hiding serious errors. It can mask bugs and make your program behave unexpectedly. Always catch specific exceptions like 'except ValueError:' or use 'except Exception:' at minimum to allow system-level exceptions to propagate properly.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references that reference counting can't resolve. The garbage collector runs periodically and can be manually triggered using the 'gc' module, though this is rarely necessary.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What does this code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using 'if x % 2 == 0', then squares each even number with 'x**2'. The result will be [0, 4, 16, 36, 64] representing squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle race conditions when using asyncio?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Event() to coordinate access to shared resources. Wrap critical sections with 'async with lock:' to ensure only one coroutine accesses the resource at a time. For simple cases, consider using asyncio.Queue for safe communication between coroutines instead of shared variables.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between merge sort and quick sort?",
    "answer": "Merge sort has guaranteed O(n log n) time complexity and is stable (preserves relative order of equal elements) but requires O(n) extra space. Quick sort has average O(n log n) but worst-case O(n\u00b2) time complexity, uses O(log n) space, but is generally faster in practice due to better cache performance. Choose merge sort for guaranteed performance and stability, quick sort for average-case speed.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I properly close files in Python?",
    "answer": "Always use the 'with' statement when working with files: 'with open('file.txt', 'r') as f: content = f.read()'. This ensures the file is automatically closed even if an exception occurs, preventing resource leaks. Avoid manually calling f.close() as it won't execute if an exception happens before that line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Both are ordered collections that can store multiple data types.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries that would otherwise block your program. Define functions with 'async def' and call them with 'await' inside other async functions. This allows your program to handle other tasks while waiting for slow operations to complete, improving performance in concurrent scenarios.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize this. This makes dictionaries excellent for fast key-based lookups compared to lists which require O(n) for searching.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python program that's not working as expected?",
    "answer": "Start by adding print statements to see variable values at different points in your code. Use Python's built-in debugger (pdb) with 'import pdb; pdb.set_trace()' to step through code line by line. Check for common issues like indentation errors, variable typos, and incorrect data types. IDE debuggers also provide visual debugging with breakpoints and variable inspection.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value (equality), while 'is' checks if they are the same object in memory (identity). Use '==' for comparing values and 'is' for checking if variables point to the same object. A common example is 'is None' for checking None values, since None is a singleton object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL allows only one Python thread to execute at a time, making threading ineffective for CPU-bound tasks in CPython. However, threading is still useful for I/O-bound tasks since the GIL is released during I/O operations. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy?",
    "answer": "A shallow copy creates a new object but references to nested objects remain the same, while a deep copy creates new objects for all levels including nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copies are faster but changes to nested objects affect both copies, while deep copies are independent but slower.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except' clauses. Always catch the most specific exception types first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions, and consider 'else' for code that should only run when no exceptions occur.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is a decorator in Python and how does it work?",
    "answer": "A decorator is a function that modifies or extends another function's behavior without changing its code. It uses the @ symbol and works by wrapping the original function. Decorators are commonly used for logging, timing, authentication, and caching. They follow the pattern of taking a function as input and returning a modified version of that function.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I optimize the performance of a recursive algorithm that has overlapping subproblems?",
    "answer": "Use memoization to cache results of expensive function calls, avoiding redundant calculations for the same inputs. You can implement this with a dictionary or use Python's @lru_cache decorator from functools. Alternatively, convert the recursive solution to dynamic programming with bottom-up iteration. This can reduce time complexity from exponential to polynomial in many cases.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are typically used when you need to modify the collection, while tuples are used for fixed data that shouldn't change. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print() statements at key points to trace variable values and program flow. Use the Python debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure your conditional statements are working as expected. Consider using an IDE with debugging features for a more visual debugging experience.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that would otherwise block your program. It's particularly useful when you need to handle multiple operations concurrently without using threads. Async/await allows your program to switch between tasks while waiting for I/O operations to complete, making it more efficient than synchronous code for these scenarios.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to their hash table implementation. In the worst case scenario (when there are many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries extremely efficient for key-based lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than using bare 'except:' statements. Always catch the most specific exception types first, then more general ones. Use 'finally' for cleanup code that must run regardless of whether an exception occurred. For example: try your risky code, except SpecificError as e: handle it appropriately, and consider logging errors for debugging purposes.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between await and asyncio.gather() in Python?",
    "answer": "The 'await' keyword is used to wait for a single coroutine to complete, pausing execution until it finishes. 'asyncio.gather()' is used to run multiple coroutines concurrently and wait for all of them to complete, returning their results as a list. Use 'await' for sequential operations and 'asyncio.gather()' when you want to parallelize multiple async operations for better performance.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when should I worry about it?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deallocating objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles. You typically don't need to worry about garbage collection in normal Python code, but be aware of it when creating circular references, using large data structures, or in long-running applications where memory leaks could accumulate.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions are a concise way to create lists using a single line of code with the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations. Use them for straightforward operations like filtering or transforming data, but avoid them for complex logic where a regular loop would be clearer.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n), making it much faster than linear search for large datasets. Remember that the array must be sorted for binary search to work correctly.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work internally?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying their code. They work by taking a function as an argument and returning a modified version of that function. When you use @decorator_name above a function, Python essentially calls decorator_name(original_function) and replaces the original function with the result. This is based on Python's first-class function support and closure mechanism.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries that would otherwise block your program. Define functions with 'async def' and call them with 'await' inside other async functions. You'll need to use asyncio.run() to execute async code from a synchronous context, and it's most beneficial when you have multiple concurrent operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "My Python code is running slowly. What are some debugging techniques to find bottlenecks?",
    "answer": "Use the built-in 'cProfile' module to profile your code and identify which functions consume the most time. Add timing statements with 'time.time()' around suspected slow sections, or use the 'timeit' module for precise measurements. Consider using 'memory_profiler' to check for memory issues, and examine your algorithms for unnecessary loops or inefficient data structure usage.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is Big O notation and why does it matter?",
    "answer": "Big O notation describes how an algorithm's performance scales with input size, focusing on the worst-case scenario. It helps you compare algorithms and predict how they'll behave with large datasets. For example, O(n) means performance scales linearly with input size, while O(n\u00b2) means it scales quadratically, making it much slower for large inputs.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python without catching too broadly?",
    "answer": "Catch specific exceptions rather than using bare 'except:' clauses, and only catch exceptions you can meaningfully handle. Use multiple except blocks for different exception types, and consider using 'finally' for cleanup code. Always log or handle exceptions appropriately - either recover gracefully, provide user feedback, or re-raise with additional context using 'raise' or 'raise from'.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects in the original, while a deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy prevents this but uses more memory and time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I create a simple for loop in Python?",
    "answer": "Use 'for variable in iterable:' syntax, where iterable can be a list, string, range, etc. For example: 'for i in range(5):' loops from 0 to 4, or 'for item in my_list:' iterates through each element. Always remember to indent the code block that should execute in each iteration.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create a custom one?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. Create one by defining a function that takes another function as an argument and returns a wrapper function. Use @decorator_name above the function definition to apply it. Common use cases include logging, timing, authentication, and caching functionality.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I efficiently find the intersection of two large lists in Python?",
    "answer": "Convert both lists to sets and use the intersection operator (&) or intersection() method for O(n + m) time complexity. For example: 'set(list1) & set(list2)'. If you need to preserve order or duplicates, use list comprehension with membership testing on a set: '[x for x in list1 if x in set(list2)]'. Avoid nested loops which would be O(n * m) complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the Global Interpreter Lock (GIL) in Python and how does it affect multithreading?",
    "answer": "The GIL is a mutex that prevents multiple Python threads from executing bytecode simultaneously, effectively making Python single-threaded for CPU-bound tasks. It exists to protect Python's memory management from race conditions. For CPU-bound work, use multiprocessing instead of threading, but threading still works well for I/O-bound tasks since the GIL is released during I/O operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable, meaning you can modify its elements after creation, while a tuple is immutable and cannot be changed once created. Lists use square brackets [] and are good for data that needs to change, while tuples use parentheses () and are ideal for fixed collections of items. Lists have methods like append() and remove(), but tuples have fewer methods since they can't be modified.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing a NameError?",
    "answer": "A NameError occurs when Python can't find a variable or function name you're trying to use. Check that you've spelled the variable name correctly, that it's defined before you try to use it, and that it's in the correct scope. You can use print() statements or a debugger like pdb to trace where the variable should be defined and verify its value.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python and what are the benefits?",
    "answer": "Use async/await when your code performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async/await allows your program to handle other tasks while waiting for these operations to complete, improving performance and responsiveness. It's particularly useful for web scraping, API calls, or building web servers that need to handle multiple requests concurrently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case scenario, when there are many hash collisions, it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small and focused on a single task. Write docstrings for your functions and classes, handle exceptions appropriately, and avoid deep nesting by using early returns. Additionally, use list comprehensions for simple operations and consider type hints for better code documentation and IDE support.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically freeing objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references that reference counting can't resolve. Issues can arise with circular references in large applications, memory leaks in long-running processes, or performance impacts during collection cycles, which can be mitigated by using weak references or manually triggering collection at appropriate times.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deepcopy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but references to nested objects are shared with the original, while a deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster and uses less memory, but changes to nested mutable objects affect both copies, whereas deep copy prevents this but is more expensive.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle multiple asynchronous operations concurrently in Python?",
    "answer": "Use asyncio.gather() to run multiple coroutines concurrently and wait for all to complete, or asyncio.as_completed() to process results as they become available. For more control, you can use asyncio.create_task() to schedule coroutines and then await them individually. These approaches are much more efficient than running async operations sequentially with individual await statements.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is a Python generator and why would I use one?",
    "answer": "A generator is a special type of iterator that yields values one at a time using the yield keyword, allowing you to create memory-efficient sequences. Unlike lists that store all elements in memory, generators produce values on-demand, making them ideal for large datasets or infinite sequences. They're particularly useful for processing large files, creating data pipelines, or any situation where you don't need all values at once.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize the performance of a Python function that processes large amounts of data?",
    "answer": "Profile your code first using cProfile to identify bottlenecks, then consider using built-in functions and libraries like NumPy for numerical operations, which are implemented in C. Use list comprehensions instead of loops where appropriate, avoid repeated function calls in loops, and consider using generators for memory efficiency. For CPU-intensive tasks, multiprocessing can help, while asyncio is better for I/O-bound operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that might change, while tuples are ideal for data that should remain constant, like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing with no error message?",
    "answer": "Start by running your script with the -u flag (python -u script.py) to see unbuffered output, and add print statements at key points to identify where it stops. Use try-except blocks around suspicious code sections to catch and display any hidden exceptions. You can also run your script in a debugger like pdb or use an IDE's debugging tools to step through the code line by line.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program involves I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async programming is excellent for handling many concurrent operations efficiently, such as web scraping multiple URLs or serving many web requests. However, avoid async/await for CPU-intensive tasks as it won't provide performance benefits and may add unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10) (numbers 0-9), filters for even numbers using `if x % 2 == 0`, and squares each even number with `x**2`. The resulting list will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python without catching too broadly?",
    "answer": "Catch specific exceptions rather than using bare `except:` clauses, and only catch exceptions you can meaningfully handle. Use multiple except blocks for different exception types, and consider using `except Exception as e:` if you need to catch multiple types while still avoiding system exceptions like KeyboardInterrupt. Always log or handle the exception appropriately, and use `finally:` blocks for cleanup code that must run regardless of success or failure.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare in practice. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search time.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I avoid race conditions when using async/await with shared data?",
    "answer": "Use asyncio.Lock() to protect critical sections where shared data is modified, ensuring only one coroutine can access the data at a time. For simple cases, consider using asyncio.Queue for safe data passing between coroutines. You can also use asyncio.Semaphore to limit concurrent access to resources, and always be careful about when you use `await` within critical sections as it can yield control to other coroutines.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between `==` and `is` operators in Python?",
    "answer": "`==` compares the values of objects to check if they're equal, while `is` compares object identity (whether they're the same object in memory). Use `==` for comparing values and `is` for comparing with None, True, False, or when you specifically need to check if two variables reference the same object. For example, `[1,2,3] == [1,2,3]` is True, but `[1,2,3] is [1,2,3]` is False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm efficiently in Python?",
    "answer": "Use two pointers (left and right) to maintain the search range, and repeatedly divide the sorted array in half by comparing the middle element with the target. If the middle element equals the target, return its index; if it's less than the target, search the right half; otherwise, search the left half. This approach has O(log n) time complexity and can be implemented iteratively to avoid recursion overhead.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and write docstrings for functions and classes. Keep functions small and focused on a single responsibility, avoid deep nesting with guard clauses, and use list comprehensions judiciously (prefer readability over cleverness). Always handle exceptions appropriately and write unit tests for your code.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like network requests, file operations, or database queries. Define functions with 'async def' and use 'await' before calling other async functions or operations. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle multiple concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this error mean: 'IndexError: list index out of range'?",
    "answer": "This error occurs when you try to access a list element at an index that doesn't exist. For example, accessing index 5 in a list that only has 3 elements (indices 0, 1, 2). To fix it, check the list length with len() before accessing indices, or use try/except blocks to handle the error gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of different dictionary operations in Python?",
    "answer": "Dictionary operations in Python have average O(1) time complexity for get, set, and delete operations due to hash table implementation. However, in worst-case scenarios (many hash collisions), these can degrade to O(n). Dictionary iteration is O(n) where n is the number of key-value pairs.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collector work and when might I need to worry about it?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically freeing objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references. You typically only need to worry about it in memory-intensive applications or when dealing with circular references, external resources, or C extensions that may not follow Python's memory management.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and how do I use them?",
    "answer": "List comprehensions provide a concise way to create lists using the syntax [expression for item in iterable if condition]. For example, [x**2 for x in range(10) if x % 2 == 0] creates a list of squares of even numbers. They're more readable and often faster than equivalent for loops, but should be kept simple for maintainability.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between merge sort and quick sort algorithms?",
    "answer": "Merge sort has guaranteed O(n log n) time complexity and is stable (preserves order of equal elements) but requires O(n) extra space. Quick sort has average O(n log n) but worst-case O(n\u00b2) time complexity, uses O(log n) space, and is not stable. Merge sort is preferred for stability and predictable performance, while quick sort is often faster in practice.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug my Python code effectively?",
    "answer": "Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at breakpoints, or use IDE debuggers for visual debugging. Add strategic print statements to trace execution flow and variable values. Use logging instead of print for production code, and consider tools like pytest for test-driven debugging.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices I should follow?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable names, and keep functions small and focused on single tasks. Write docstrings for functions and classes, handle exceptions appropriately, and use virtual environments for project dependencies. Also, write tests for your code and use version control like Git.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle race conditions when using asyncio in Python?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Queue() to coordinate access to shared resources. Avoid shared mutable state when possible, and use asyncio.gather() or asyncio.create_task() properly to manage concurrent operations. Always use 'async with' for locks and ensure proper exception handling to prevent deadlocks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's crashing with a NameError?",
    "answer": "A NameError occurs when you try to use a variable or function that hasn't been defined or is out of scope. Check for typos in variable names, ensure variables are defined before use, and verify proper indentation for scope. You can also use print statements or a debugger like pdb to trace where the undefined variable is being referenced.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular functions?",
    "answer": "Use async/await when your code performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async functions allow other code to run while waiting for these operations to complete, improving performance in I/O-bound applications. However, avoid async for CPU-intensive tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists which require O(n) time for searching.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, and add docstrings to functions and classes. Keep functions small and focused on a single responsibility, use type hints for better code documentation, and include comments for complex logic. Consistent formatting and meaningful naming make code much easier to understand and maintain.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await asyncio.gather()` and `await asyncio.wait()`?",
    "answer": "`asyncio.gather()` runs coroutines concurrently and returns results in the same order as input, raising an exception immediately if any coroutine fails. `asyncio.wait()` provides more control, returning completed and pending tasks separately, and allows you to specify when to return (first completion, first exception, or all done). Use `gather()` for simple concurrent execution and `wait()` when you need fine-grained control over task completion.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search repeatedly divides a sorted array in half, comparing the target with the middle element. If the target is smaller, search the left half; if larger, search the right half. Here's a basic implementation: `def binary_search(arr, target): left, right = 0, len(arr) - 1; while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1; return -1`. This achieves O(log n) time complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or enhance other functions without changing their code directly. They use the `@decorator_name` syntax above a function definition and work by wrapping the original function. Common use cases include logging, timing, authentication, and caching. The decorator receives the original function as an argument and typically returns a wrapper function that adds functionality before/after calling the original.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why is my Python loop running slowly and how can I optimize it?",
    "answer": "Common causes include unnecessary repeated calculations inside the loop, using inefficient data structures, or performing I/O operations. Move invariant calculations outside the loop, use appropriate data structures (sets for membership testing, dictionaries for lookups), and consider list comprehensions or built-in functions like `map()` and `filter()`. For large datasets, libraries like NumPy can provide significant speed improvements.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare `except:` statements, which can hide bugs. Always catch the most specific exception types first, use `finally` for cleanup code that must run regardless of exceptions, and consider using `else` for code that should only run if no exception occurred. Avoid using exceptions for normal control flow as they're expensive performance-wise.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets [], while a tuple is immutable (cannot be changed) and uses parentheses (). Lists are better for data that needs to change, while tuples are ideal for fixed data like coordinates or database records. Tuples also use slightly less memory and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure your conditional statements and loops are working as expected.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that involve waiting. It allows other code to run while waiting for these operations to complete, improving performance for I/O-bound tasks. Don't use it for CPU-intensive tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (very rare), it can degrade to O(n) when there are many hash collisions. This makes dictionaries extremely efficient for key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, and write docstrings for functions and classes. Keep functions small and focused on single tasks, avoid deep nesting, and add comments to explain complex logic. Use meaningful variable names like 'user_count' instead of 'x' or 'data'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does this code do: `[x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result is [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare 'except:' clauses. Handle exceptions at the appropriate level where you can take meaningful action. Always clean up resources using 'finally' blocks or context managers (with statements). Log errors appropriately and don't suppress exceptions unless you have a good reason.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await asyncio.gather()` and `await asyncio.wait()`?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception if any task fails. asyncio.wait() gives more control, returning done and pending sets, and allows you to specify when to return (first completed, first exception, or all completed). Use gather() for simple concurrent execution, wait() for more complex coordination scenarios.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using global variables in my Python functions?",
    "answer": "Global variables make code harder to test, debug, and understand because functions have hidden dependencies. They can lead to unexpected side effects and make it difficult to reason about function behavior. Instead, pass data as parameters and return values, which makes functions more predictable, reusable, and easier to test in isolation.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a recursive algorithm that's running too slowly?",
    "answer": "Consider using memoization to cache results of expensive function calls, or convert to an iterative solution using a stack or queue. Dynamic programming can replace overlapping recursive calls with bottom-up computation. You can also use Python's @lru_cache decorator for automatic memoization, or implement tail recursion optimization manually by restructuring the algorithm.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access a list/string index that doesn't exist. Add print statements to check the length of your collection and the index you're trying to access. Use try-except blocks to catch the error gracefully, or add bounds checking with 'if index < len(my_list):' before accessing elements.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries that involve waiting. It allows other code to run while waiting for these operations to complete, improving performance for concurrent tasks. Don't use async/await for CPU-bound tasks as it won't provide performance benefits and may add unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, and keep functions small with single responsibilities. Add docstrings to document functions and classes, use type hints for better code clarity, and organize code into logical modules. Consistent indentation and meaningful comments for complex logic also greatly improve readability.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await asyncio.gather()' and 'await asyncio.wait()'?",
    "answer": "asyncio.gather() returns results in the same order as input coroutines and raises an exception immediately if any task fails. asyncio.wait() returns two sets (done and pending) and doesn't preserve order, giving you more control over handling individual task failures. Use gather() for simple concurrent execution, and wait() when you need fine-grained control over completion handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I efficiently find the intersection of two large lists in Python?",
    "answer": "Convert both lists to sets and use the intersection operator: 'set(list1) & set(list2)'. This has O(n + m) time complexity compared to O(n*m) for nested loops. If you need to preserve duplicates or order, consider using collections.Counter for counting elements or converting one list to a set for O(n) lookup during iteration.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why is my recursive function causing a 'RecursionError: maximum recursion depth exceeded'?",
    "answer": "This error occurs when your recursive function calls itself too many times without reaching a base case, or the recursion depth exceeds Python's limit (usually ~1000). Check that your base case is correct and reachable, and that each recursive call moves closer to the base case. For deep recursions, consider iterative solutions or increase the recursion limit with sys.setrecursionlimit().",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's a memory-efficient way to process a very large file in Python?",
    "answer": "Use a generator or iterator approach by reading the file line by line with 'for line in file:' instead of 'file.read()' or 'file.readlines()'. This loads only one line into memory at a time rather than the entire file. For structured data, consider using pandas with chunking or libraries like ijson for streaming JSON parsing.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await?",
    "answer": "Use try-except blocks around await statements just like synchronous code, but be aware that exceptions in background tasks won't propagate automatically. For multiple concurrent tasks, use asyncio.gather() with return_exceptions=True or handle exceptions individually when using asyncio.create_task(). Always await tasks you create to ensure exceptions are properly raised.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. You need an event loop (like asyncio.run()) to execute async code. This allows your program to handle other tasks while waiting for slow operations to complete.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists which require O(n) time for searches.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's not producing any output?",
    "answer": "First, add print statements at key points to trace execution flow. Check if your script is actually running the code you expect (ensure proper indentation and function calls). Use a debugger like pdb by adding 'import pdb; pdb.set_trace()' or run with 'python -m pdb script.py'. Also verify that output isn't being buffered - try sys.stdout.flush() or run with 'python -u'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python context managers and why should I use them?",
    "answer": "Context managers automatically handle resource setup and cleanup using the 'with' statement, ensuring resources are properly released even if errors occur. They implement __enter__ and __exit__ methods, or you can use the @contextmanager decorator. Common examples include file handling, database connections, and thread locks. This prevents resource leaks and makes code more robust and readable.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search requires a sorted array and repeatedly divides the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the key: left, right = 0, len(arr)-1, then mid = (left + right) // 2, updating left or right based on comparison until found or left > right.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does the 'self' parameter do in Python class methods?",
    "answer": "The 'self' parameter represents the instance of the class and must be the first parameter in instance methods. It allows you to access instance variables and other methods within the class. When you call a method on an object, Python automatically passes the object as the 'self' argument. You can name it something else, but 'self' is the strong convention.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle race conditions when using asyncio with shared data?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Event() to coordinate access to shared resources. Wrap critical sections with 'async with lock:' to ensure only one coroutine accesses shared data at a time. Alternatively, use asyncio.Queue for thread-safe communication between coroutines. Avoid using threading locks with asyncio as they can block the event loop.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are list comprehensions and when should I use them instead of regular loops?",
    "answer": "List comprehensions create new lists using concise syntax: [expression for item in iterable if condition]. They're more Pythonic and often faster than equivalent for loops when creating lists. Use them for simple transformations and filtering, but avoid them for complex logic or when you don't need a new list. They improve readability for common patterns like [x*2 for x in numbers if x > 0].",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a custom hash function for a Python class to use it as a dictionary key?",
    "answer": "Implement both __hash__ and __eq__ methods in your class. The __hash__ method should return an integer based on immutable attributes, and objects that compare equal must have the same hash value. Use hash(tuple_of_immutable_attributes) for combining multiple values. Remember that mutable objects shouldn't be hashable, so ensure your object's hash-relevant attributes don't change after creation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are typically used for collections of similar items that may change, while tuples are used for fixed collections like coordinates or database records. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot be changed once created.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check for common issues like incorrect indentation, variable scope problems, or logical errors in conditions. Consider using an IDE with debugging features or logging instead of print statements for more complex applications.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python and what are the benefits?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries where your program would otherwise wait idly. Async programming allows your program to handle other tasks while waiting for these operations to complete, improving overall performance and responsiveness. It's particularly beneficial for web servers, API clients, or any application that deals with multiple concurrent operations. However, avoid async for CPU-bound tasks as it won't provide performance benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case scenario (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for lookups compared to lists which have O(n) search time. The fast lookup time is why dictionaries are preferred for mapping relationships and caching.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare except clauses, and handle different exception types appropriately. Always catch the most specific exception first, then broader ones, and consider using finally blocks for cleanup code. For example: try your risky code, except ValueError for specific errors, except Exception for broader catching, and use finally for cleanup. Avoid catching and ignoring exceptions without proper handling or logging.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between shallow copy and deep copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to mutable nested objects affect both copies, while deep copy is slower but creates completely independent copies. Choose based on whether you need to modify nested objects independently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, and write clear docstrings for functions and classes. Keep functions small and focused on single responsibilities, avoid deep nesting, and use meaningful comments for complex logic. Structure your code with proper imports, consistent formatting, and logical organization into modules and packages. Regular refactoring and code reviews also help maintain clean, readable code.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "Explain how Python's Global Interpreter Lock (GIL) affects multithreading performance.",
    "answer": "The GIL prevents multiple Python threads from executing bytecode simultaneously, effectively limiting true parallelism for CPU-bound tasks. While threads can still be beneficial for I/O-bound operations (as the GIL is released during I/O waits), CPU-intensive tasks won't see performance improvements and may even be slower due to context switching overhead. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying them, using the @decorator syntax. They work by taking a function as input and returning a modified version, essentially wrapping the original function. Common use cases include logging, timing, authentication, and caching. For example, @property converts a method into a getter, and @staticmethod creates methods that don't need class or instance references.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a custom context manager in Python?",
    "answer": "Implement a custom context manager by defining __enter__ and __exit__ methods in a class, or use the @contextmanager decorator with a generator function. The __enter__ method runs when entering the 'with' block and returns the resource, while __exit__ handles cleanup and receives exception information. Using @contextmanager, you yield the resource and put cleanup code after the yield statement. Context managers ensure proper resource management and cleanup even when exceptions occur.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is a mutable data structure that can be modified after creation, while a tuple is immutable and cannot be changed once created. Lists use square brackets [] and support operations like append() and remove(), whereas tuples use parentheses () and are more memory-efficient. Use lists when you need to modify data and tuples when you need a fixed collection of items.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like file reading, network requests, or database queries that would otherwise block your program. Async/await allows other code to run while waiting for these operations to complete, improving performance in concurrent scenarios. However, avoid async/await for CPU-bound tasks as it won't provide benefits and may add unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing expected output?",
    "answer": "Start by adding print() statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure your conditional statements and loops are working as expected.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case scenario (many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why is my async function not running concurrently with other code?",
    "answer": "You're likely calling the async function with regular function call syntax instead of awaiting it properly, or not using an event loop. Async functions need to be called with 'await' inside another async function, or run with asyncio.run() or asyncio.create_task() to execute concurrently. Simply defining a function as 'async def' doesn't make it run asynchronously automatically.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions are a concise way to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops when creating new lists. Use them for simple transformations and filtering, but avoid them for complex logic where a regular loop would be clearer.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions without catching all errors indiscriminately?",
    "answer": "Catch specific exception types rather than using bare 'except:' clauses, for example 'except ValueError:' or 'except (TypeError, KeyError):'. This prevents masking unexpected errors and makes debugging easier. Always log or handle the exception appropriately, and consider using 'finally:' blocks for cleanup code that must run regardless of success or failure.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copies are faster but changes to nested mutable objects affect both copies, whereas deep copies are completely independent.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I efficiently find the most frequent element in a Python list?",
    "answer": "Use collections.Counter which creates a dictionary-like object counting element frequencies, then call most_common(1) to get the most frequent item. Alternatively, use max(set(list), key=list.count) but this is less efficient for large lists. Counter is generally the best approach as it's both readable and performs well with O(n) time complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does the 'if __name__ == \"__main__\":' statement do?",
    "answer": "This statement checks if the Python script is being run directly (not imported as a module). Code inside this block only executes when the script is the main program, not when it's imported by another script. This is a best practice that allows your script to be both executable and importable, making it more reusable and testable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or database records.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming to handle I/O-bound operations without blocking the main thread. You define async functions with 'async def' and call them with 'await'. Use it for operations like API calls, file I/O, or database queries where you're waiting for external resources.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Searching in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare in practice with Python's optimized hash function.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why is my Python code running slowly and how can I debug performance issues?",
    "answer": "Common causes include inefficient algorithms, unnecessary loops, or blocking I/O operations. Use profiling tools like cProfile or line_profiler to identify bottlenecks, check for nested loops with high complexity, and consider using built-in functions or libraries like NumPy for heavy computations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squared even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number, resulting in [0, 4, 16, 36, 64].",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await?",
    "answer": "Use try/except blocks around await statements just like synchronous code. For multiple async operations, consider using asyncio.gather() with return_exceptions=True to handle failures gracefully. Always ensure proper cleanup in finally blocks, especially for resources like database connections.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between append() and extend() methods for Python lists?",
    "answer": "append() adds a single element to the end of a list, while extend() adds multiple elements from an iterable. For example, list.append([1,2]) adds the entire list as one element, but list.extend([1,2]) adds 1 and 2 as separate elements.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use a set vs a list in Python?",
    "answer": "Use a set when you need unique elements and fast membership testing (O(1) average case), or when performing set operations like union/intersection. Use a list when you need to maintain order, allow duplicates, or access elements by index.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's hanging or not responding?",
    "answer": "First, check for infinite loops or blocking I/O operations. Use Ctrl+C to interrupt and see the stack trace, or add print statements to track execution flow. For more complex issues, use pdb debugger or IDE breakpoints to step through code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between asyncio.create_task() and just using await?",
    "answer": "await pauses execution until the awaited operation completes, running tasks sequentially. asyncio.create_task() schedules a coroutine to run concurrently, allowing multiple tasks to execute simultaneously. Use create_task() when you want parallelism, and direct await when you need sequential execution or immediate results.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like making HTTP requests, reading files, or database queries that would otherwise block your program. Async programming allows other code to run while waiting for these operations to complete, improving performance for concurrent tasks. However, avoid async/await for CPU-bound tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but producing wrong output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step-by-step, verify input data, and test edge cases. Modern IDEs also provide visual debugging tools that let you set breakpoints and inspect variables.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different Python data structure operations?",
    "answer": "Lists have O(1) for append/access by index but O(n) for insert/delete at arbitrary positions. Dictionaries and sets have average O(1) for lookup, insert, and delete operations due to hash tables. Deques from collections module offer O(1) append/pop from both ends. Understanding these complexities helps you choose the right data structure for optimal performance.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Explain what this list comprehension does: [x**2 for x in range(10) if x % 2 == 0]",
    "answer": "This creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10) (numbers 0-9), filters for even numbers using 'if x % 2 == 0', then squares each even number with 'x**2'. The result is [0, 4, 16, 36, 64], representing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions and why do they matter?",
    "answer": "Follow PEP 8: use snake_case for variables and functions, PascalCase for classes, and UPPER_CASE for constants. Private methods start with underscore (_private_method), and 'dunder' methods use double underscores (__init__). Consistent naming improves code readability, makes collaboration easier, and follows community standards that other Python developers expect.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's GIL affect async programming and multithreading?",
    "answer": "The Global Interpreter Lock (GIL) prevents true parallel execution of Python threads, but async/await works differently by using cooperative multitasking within a single thread. Async code yields control during I/O operations, allowing other coroutines to run, which bypasses GIL limitations. For CPU-bound parallelism, use multiprocessing instead of threading or async/await.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between shallow and deep copy in Python?",
    "answer": "Shallow copy creates a new object but inserts references to objects in the original, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster but changes to nested mutable objects affect both copies; deep copy prevents this but uses more memory and time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the key: maintain left and right pointers, calculate mid = (left + right) // 2, and update pointers based on comparison until found or left > right.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are context managers and how do you create custom ones?",
    "answer": "Context managers ensure proper resource management using the 'with' statement, automatically handling setup and cleanup. Create custom ones by defining __enter__ and __exit__ methods in a class, or use the @contextmanager decorator with yield. The __exit__ method receives exception information and can suppress exceptions by returning True, making them perfect for file handling, database connections, and lock management.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that would otherwise block your program. Async programming allows other code to run while waiting for these operations to complete, improving overall performance. However, avoid async for CPU-bound tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing a NameError?",
    "answer": "A NameError occurs when Python can't find a variable or function name you're trying to use. Check for typos in variable names, ensure variables are defined before use, verify function names are spelled correctly, and make sure you've imported any required modules. Use print statements or a debugger to trace where the undefined name is first referenced.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean functions?",
    "answer": "Write functions that do one thing well (single responsibility principle), use descriptive names, keep functions short (ideally under 20 lines), and include docstrings to explain purpose and parameters. Avoid global variables, use type hints for clarity, and follow the DRY principle (Don't Repeat Yourself) by extracting common code into reusable functions.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Can you explain what this Python list comprehension does: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This list comprehension creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10) (numbers 0-9), filters for even numbers using 'if x % 2 == 0', and squares each even number with 'x**2'. The result is [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations in Python have an average time complexity of O(1) for lookup, insertion, and deletion due to hash table implementation. However, in worst-case scenarios (with many hash collisions), these operations can degrade to O(n). Iterating through all keys/values is O(n), and the space complexity is O(n) where n is the number of key-value pairs.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, immediately deallocating objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles between objects. Issues can arise with circular references in large applications, memory leaks in C extensions, or performance hiccups during garbage collection cycles in real-time applications.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between awaiting multiple async functions with asyncio.gather() vs asyncio.wait()?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception if any coroutine fails. asyncio.wait() provides more control, returning done and pending sets, and allows you to specify when to return (first completed, first exception, or all completed). Use gather() for simple concurrent execution and wait() when you need fine-grained control over completion handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why is my Python code running slowly and how can I identify bottlenecks?",
    "answer": "Use profiling tools like cProfile or line_profiler to identify which functions consume the most time. Common performance issues include inefficient algorithms (check time complexity), unnecessary loops, repeated expensive operations, or blocking I/O operations. Consider using built-in functions, list comprehensions, or libraries like NumPy for mathematical operations, and implement caching for expensive computations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a simple binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a basic implementation: def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1; return -1",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that might change, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I fix a NameError in Python?",
    "answer": "A NameError occurs when you try to use a variable that hasn't been defined yet. Check that you've spelled the variable name correctly, defined it before using it, and that it's in the correct scope. Common causes include typos, using a variable before assignment, or trying to access a local variable outside its function.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like web requests, file operations, or database queries that can run concurrently. It's particularly useful when you need to handle many operations simultaneously without blocking the main thread. However, avoid it for CPU-bound tasks as it won't provide performance benefits and may add unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize this. This makes dictionaries extremely efficient for key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare except clauses. Always catch the most specific exception first, then more general ones. Use finally blocks for cleanup code that must run regardless of success or failure. Consider using else blocks for code that should only run if no exceptions occurred.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between '==' and 'is' in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables point to the same object in memory). Use '==' for comparing values and 'is' for comparing with None or checking if two variables reference the exact same object. For example: [1,2] == [1,2] is True, but [1,2] is [1,2] is False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL ensures that only one thread executes Python bytecode at a time, which means CPU-bound multithreaded programs don't achieve true parallelism. However, I/O-bound operations release the GIL, making threading effective for such tasks. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to concatenate many strings in Python?",
    "answer": "Use join() method with a list for multiple concatenations: ''.join(['string1', 'string2', 'string3']). Avoid using += in loops as it creates new string objects each time, leading to O(n\u00b2) complexity. For a few concatenations, f-strings or format() are readable and efficient. StringIO is another option for building large strings incrementally.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a simple binary search algorithm in Python?",
    "answer": "Binary search requires a sorted array and repeatedly divides the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n). Here's the key: always update your left/right pointers to mid+1 or mid-1 to avoid infinite loops.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. They use the @ syntax and work by taking a function as input and returning a modified version. Common uses include logging, timing, authentication, and caching. The decorator pattern leverages Python's first-class functions and closures to wrap functionality around existing code.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also faster to access and can be used as dictionary keys, unlike lists.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing a KeyError?",
    "answer": "A KeyError occurs when trying to access a dictionary key that doesn't exist. Use try-except blocks to handle missing keys gracefully, or use the .get() method with a default value. You can also use 'key in dictionary' to check if a key exists before accessing it. Print statements or a debugger can help identify which key is missing.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources. It allows other code to run while waiting, improving performance for concurrent operations. Don't use it for CPU-intensive tasks, as Python's GIL limits true parallelism for compute-bound work.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of common Python list operations?",
    "answer": "Accessing by index is O(1), appending to the end is O(1), but inserting at the beginning is O(n) because all elements must shift. Searching for a value is O(n), and removing an element is O(n) in the worst case. Understanding these complexities helps you choose the right data structure for your use case.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element, then search either the left or right half. Here's the basic structure: while left <= right, calculate mid, compare target with arr[mid], and update left or right boundaries accordingly. Time complexity is O(log n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions and why do they matter?",
    "answer": "Use snake_case for variables and functions, PascalCase for classes, and UPPER_CASE for constants. Private attributes start with underscore, and 'dunder' methods use double underscores. Following PEP 8 conventions makes code readable and maintainable for other developers. Consistent naming reduces cognitive load when reading code.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle multiple async operations concurrently?",
    "answer": "Use asyncio.gather() to run multiple coroutines concurrently and wait for all to complete, or asyncio.create_task() to schedule coroutines for concurrent execution. For more control, use asyncio.as_completed() to process results as they become available. Always await the results and handle exceptions appropriately with try-except blocks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested objects affect both copies, while deep copy is slower but provides complete independence.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I optimize a slow Python function?",
    "answer": "Start by profiling with cProfile to identify bottlenecks, then consider using built-in functions, list comprehensions, or libraries like NumPy for numerical operations. Cache expensive computations with functools.lru_cache, avoid repeated database queries, and use appropriate data structures. Sometimes moving CPU-intensive code to C extensions or using PyPy can provide significant speedups.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What does the 'if __name__ == \"__main__\":' block do?",
    "answer": "This block ensures code only runs when the script is executed directly, not when imported as a module. When Python runs a file, it sets __name__ to \"__main__\", but when importing, __name__ becomes the module name. This pattern allows you to write reusable modules that can also be run as standalone scripts for testing or demonstration purposes.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples also have slightly better performance and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming, allowing your program to handle other tasks while waiting for I/O operations like network requests or file reads. You define async functions with 'async def' and call them with 'await'. Use async/await when you have I/O-bound operations that would otherwise block your program, such as API calls, database queries, or file operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through range(10) (0-9), filters for even numbers using 'if x % 2 == 0', and squares each even number with 'x**2'. The result will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's running slowly?",
    "answer": "Start by using Python's built-in profiler with 'python -m cProfile your_script.py' to identify bottlenecks. Use print statements or logging to track execution flow, and consider using a debugger like pdb for step-by-step analysis. For performance issues, look for inefficient loops, unnecessary database queries, or operations that could be vectorized with libraries like NumPy.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is Big O notation and why does it matter?",
    "answer": "Big O notation describes how an algorithm's performance scales with input size, focusing on the worst-case scenario. It helps you compare algorithms and predict how they'll perform with large datasets. For example, O(n) means performance scales linearly with input size, while O(n\u00b2) means it scales quadratically. Understanding Big O helps you choose efficient algorithms and avoid performance problems in production.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python best practices for writing clean code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small and focused on a single task. Write docstrings for functions and classes, handle exceptions appropriately, and avoid deep nesting by using early returns. Use type hints for better code documentation and consider using tools like pylint or black for code quality.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle race conditions when using async/await with shared resources?",
    "answer": "Use asyncio locks, semaphores, or queues to coordinate access to shared resources. For example, use 'asyncio.Lock()' to ensure only one coroutine accesses a resource at a time, or 'asyncio.Semaphore(n)' to limit concurrent access to n coroutines. Always use 'async with lock:' to ensure proper cleanup, and consider using asyncio.Queue for producer-consumer patterns to avoid direct shared state.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between merge sort and quicksort?",
    "answer": "Merge sort has guaranteed O(n log n) time complexity and is stable (maintains relative order of equal elements) but requires O(n) extra space. Quicksort averages O(n log n) but can degrade to O(n\u00b2) in worst case, uses O(log n) space, and is typically faster in practice due to better cache performance. Choose merge sort when you need guaranteed performance and stability; choose quicksort for general-purpose sorting when average-case performance matters more.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why am I getting a 'NameError' in my Python code?",
    "answer": "NameError occurs when you try to use a variable or function name that hasn't been defined or isn't in scope. Common causes include typos in variable names, using a variable before defining it, or trying to access a local variable from outside its function. Check your spelling, ensure variables are defined before use, and verify you're accessing variables in the correct scope.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a thread-safe singleton pattern in Python?",
    "answer": "Use the double-checked locking pattern with threading.Lock() or leverage Python's module import mechanism which is thread-safe by default. The cleanest approach is often using a module-level variable or the __new__ method with a lock. Alternatively, use a metaclass or decorator approach, but be aware that simple implementations without locks can fail in multi-threaded environments due to race conditions during instance creation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for data that shouldn't change, like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check for common issues like off-by-one errors, incorrect variable scope, or logical operators. Consider using an IDE with debugging features for a more visual debugging experience.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular functions?",
    "answer": "Use async/await when your code involves I/O operations like file reading, network requests, or database queries that would otherwise block execution. Async functions are ideal when you need to handle multiple operations concurrently without using threads. However, avoid async/await for CPU-intensive tasks since Python's async is designed for I/O-bound concurrency, not parallel computation.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary and why?",
    "answer": "Dictionary lookups have O(1) average time complexity because Python dictionaries are implemented using hash tables. The hash function computes an index directly from the key, allowing immediate access to the value. In worst-case scenarios with many hash collisions, it can degrade to O(n), but Python's implementation uses open addressing and dynamic resizing to minimize this risk.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python without catching too broadly?",
    "answer": "Catch specific exceptions rather than using bare 'except:' clauses, and only catch exceptions you can meaningfully handle. Use multiple except blocks for different exception types, and consider using 'finally' for cleanup code that must run regardless of success or failure. Always log or handle exceptions appropriately rather than silently ignoring them, as this can hide important bugs.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), then squares each even number (x**2). The resulting list will be [0, 4, 16, 36, 64], containing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I implement a simple LRU (Least Recently Used) cache in Python?",
    "answer": "Use Python's `functools.lru_cache` decorator for functions, or implement manually using `collections.OrderedDict`. For manual implementation, move accessed items to the end and remove items from the beginning when capacity is exceeded. The OrderedDict maintains insertion order while providing O(1) access, making it perfect for LRU logic where recent items stay at the end.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await asyncio.gather()` and `await asyncio.wait()` in Python?",
    "answer": "`asyncio.gather()` runs coroutines concurrently and returns results in the same order as input, raising an exception if any coroutine fails. `asyncio.wait()` provides more control, returning completed and pending tasks separately, and allows you to specify conditions like waiting for first completion or handling timeouts. Use `gather()` for simple concurrent execution, and `wait()` when you need fine-grained control over completion handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using mutable default arguments in Python functions?",
    "answer": "Mutable default arguments (like lists or dictionaries) are created only once when the function is defined, not each time it's called. This means the same object is reused across function calls, leading to unexpected behavior where modifications persist between calls. Instead, use `None` as the default and create the mutable object inside the function: `def func(items=None): if items is None: items = []`.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I efficiently find the intersection of two large sorted arrays?",
    "answer": "Use a two-pointer technique: start with pointers at the beginning of both arrays, compare elements, and advance the pointer with the smaller value. When elements are equal, add to result and advance both pointers. This approach has O(m + n) time complexity compared to O(m * n) for nested loops. For very large datasets, consider using set intersection if memory allows, as it provides O(m + n) average case performance.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing a NameError?",
    "answer": "A NameError occurs when you try to use a variable or function that hasn't been defined or is out of scope. Check for typos in variable names, ensure variables are defined before use, and verify proper indentation for scope. Use print statements or a debugger like pdb to trace where the undefined variable is being referenced.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that can run concurrently. This allows other code to execute while waiting for these operations to complete, improving overall performance. Don't use it for CPU-bound tasks as Python's GIL limits true parallelism for compute-intensive work.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python's naming conventions for variables and functions?",
    "answer": "Use snake_case for variables and functions (e.g., user_name, calculate_total), PascalCase for classes (e.g., UserAccount), and UPPER_CASE for constants (e.g., MAX_SIZE). Avoid single letters except for short loops, don't start with numbers, and use descriptive names that clearly indicate purpose. Private attributes should start with an underscore.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL allows only one thread to execute Python bytecode at a time, making multithreading ineffective for CPU-bound tasks. However, threads can still be beneficial for I/O-bound operations since the GIL is released during I/O waits. For CPU-intensive parallel processing, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between await and asyncio.gather() in async Python?",
    "answer": "await pauses execution until a single coroutine completes, running tasks sequentially. asyncio.gather() runs multiple coroutines concurrently and waits for all to complete, returning results in order. Use await for dependent operations and gather() when you have multiple independent async operations that can run simultaneously for better performance.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I efficiently remove duplicates from a list while preserving order?",
    "answer": "Use dict.fromkeys() for Python 3.7+ as it preserves insertion order: list(dict.fromkeys(my_list)). For older Python versions, use a set to track seen items: [x for i, x in enumerate(my_list) if x not in my_list[:i]]. The dict.fromkeys() approach is more efficient with O(n) time complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's a generator in Python and why would I use one?",
    "answer": "A generator is a function that uses yield to produce values on-demand rather than creating them all at once. They're memory-efficient for large datasets since they generate values lazily, and they implement the iterator protocol automatically. Use generators when processing large amounts of data or when you want to create infinite sequences without consuming excessive memory.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a custom exception class with proper error handling?",
    "answer": "Create a class inheriting from Exception or a specific exception type, optionally adding custom attributes and methods. Include a descriptive __str__ method and consider adding error codes or context information. Always catch specific exceptions rather than bare except clauses, and use exception chaining with 'raise ... from ...' to preserve the original traceback when re-raising.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. For example: my_list = [1, 2, 3] can be changed, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access a list/string index that doesn't exist. Use print statements or a debugger to check the length of your sequence and the index value you're trying to access. Make sure your index is between 0 and len(sequence)-1, or use try/except blocks to handle the error gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does async/await do in Python and when should I use it?",
    "answer": "Async/await enables asynchronous programming, allowing your code to handle I/O operations (like web requests or file reads) without blocking other tasks. Use async def to define asynchronous functions and await to call them. This is particularly useful for web scraping, API calls, or any application that waits for external resources frequently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) because they use hash tables internally. However, in the worst case (with many hash collisions), it can degrade to O(n). This makes dictionaries extremely efficient for key-based lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and follow best practices?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable names, write docstrings for functions, and keep functions small and focused on one task. Use meaningful comments sparingly, organize imports properly, and consider using type hints. Tools like pylint, black, and flake8 can help enforce these standards automatically.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between __str__ and __repr__ methods in Python classes?",
    "answer": "__str__ should return a human-readable string representation of the object for end users, while __repr__ should return an unambiguous string that ideally could recreate the object for developers. When you print() an object, __str__ is called, but in the interactive interpreter or debugger, __repr__ is used. If __str__ isn't defined, Python falls back to __repr__.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might I need to worry about it?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically freeing objects when no references exist. It also has a cyclic garbage collector for handling circular references. Most of the time you don't need to worry about it, but be aware of circular references in complex data structures and consider using weak references or manual cleanup for resource-heavy objects like file handles or database connections.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks if two variables point to the same object in memory (identity), while '==' checks if the values are equal (equality). For example, two different lists with the same contents will be equal (==) but not identical (is). Use 'is' for comparing with None, True, or False, and '==' for comparing values.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I efficiently find the intersection of two large lists in Python?",
    "answer": "Convert both lists to sets and use the intersection (&) operator: result = list(set(list1) & set(list2)). This reduces time complexity from O(n*m) to O(n+m) on average. If you need to preserve order or handle duplicates, consider using collections.Counter or a dictionary-based approach instead.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create a custom one that measures function execution time?",
    "answer": "Decorators are functions that modify or extend other functions without changing their code. Here's a timing decorator: python\nimport time\nfrom functools import wraps\n\ndef timing_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f'{func.__name__} took {time.time() - start:.4f} seconds')\n        return result\n    return wrapper\nUse @timing_decorator above any function to measure its execution time.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to change, like a shopping cart, while tuples are ideal for fixed data like coordinates (x, y). Both can store multiple items and maintain order.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file operations, or database queries that would otherwise block your program. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle many concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this error mean: 'IndexError: list index out of range'?",
    "answer": "This error occurs when you try to access a list element at an index that doesn't exist. For example, if a list has 3 items (indices 0, 1, 2), trying to access index 3 or higher will raise this error. To fix it, check the list length with len() or use try/except blocks to handle the error gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code. They use the @decorator_name syntax above function definitions. Decorators work by taking a function as input and returning a modified version, commonly used for logging, timing, authentication, or caching functionality.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when their reference count reaches zero. It also uses a cyclic garbage collector to handle reference cycles where objects reference each other. The gc module allows manual control, but Python's automatic memory management handles most cases efficiently without programmer intervention.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of common Python operations?",
    "answer": "List append is O(1), but insert at beginning is O(n). Dictionary get/set operations are O(1) average case. List sorting is O(n log n), and searching an unsorted list is O(n). Understanding these complexities helps you choose the right data structure and avoid performance bottlenecks in your code.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug Python code effectively?",
    "answer": "Use print statements for quick debugging, but prefer the built-in pdb debugger for complex issues. Set breakpoints with pdb.set_trace() or use your IDE's debugger to step through code line by line. Also utilize logging instead of print statements for production code, and write unit tests to catch bugs early.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster but changes to nested objects affect both copies, while deep copy is safer but more expensive.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you implement a thread-safe singleton pattern in Python?",
    "answer": "Use a lock to ensure thread safety during initialization, typically with the double-checked locking pattern or by using a metaclass approach. The threading.Lock() ensures only one thread can create the instance at a time. Alternatively, use the module-level approach since Python modules are singletons by nature, or leverage the @functools.lru_cache decorator for simpler cases.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions provide a concise way to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations. Use them for filtering, mapping, or combining operations, but avoid them for complex logic where regular loops would be clearer.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming, allowing your code to handle multiple tasks concurrently without blocking. Use 'async def' to define an async function and 'await' to call other async functions or awaitable objects. It's most beneficial for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some effective debugging techniques for Python code?",
    "answer": "Start with print statements to trace variable values and execution flow, then use Python's built-in debugger (pdb) with 'import pdb; pdb.set_trace()' for interactive debugging. Use logging instead of print for production code, and leverage IDE debuggers for setting breakpoints and step-through debugging. Don't forget to check error messages carefully and use tools like pylint for static code analysis.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations in Python have average O(1) time complexity for lookup, insertion, and deletion due to hash table implementation. However, in worst-case scenarios (many hash collisions), these operations can degrade to O(n). Iterating through all keys/values is O(n), and copying a dictionary is also O(n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically deallocating objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles between objects. Issues can arise with circular references, memory leaks in long-running applications, or performance hiccups during garbage collection cycles in memory-intensive applications.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks for object identity (whether two variables point to the same object in memory), while '==' checks for value equality. For example, two different lists with the same contents will be equal (==) but not identical (is). Use '==' for comparing values and 'is' for comparing with None or checking if objects are the exact same instance.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do you handle exceptions properly in async Python code?",
    "answer": "Use try/except blocks around await statements just like synchronous code, but be aware that exceptions in background tasks might be silently ignored. Use asyncio.gather() with return_exceptions=True to collect exceptions from multiple async tasks, and consider using asyncio.create_task() for proper exception handling in fire-and-forget scenarios. Always await tasks or use proper exception handling to avoid warnings.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and when should I use them?",
    "answer": "List comprehensions provide a concise way to create lists using the syntax [expression for item in iterable if condition]. They're more readable and often faster than equivalent for loops for simple transformations and filtering. Use them for straightforward operations, but avoid complex nested comprehensions that hurt readability.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but inserts references to objects found in the original, while deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy is independent but slower and uses more memory.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you optimize Python code for better performance?",
    "answer": "Start by profiling with tools like cProfile to identify bottlenecks, then optimize algorithmically before micro-optimizing. Use built-in functions and libraries (they're implemented in C), avoid premature optimization, and consider list comprehensions over loops. For CPU-intensive tasks, consider NumPy for numerical operations or multiprocessing for parallelization, and use generators for memory efficiency with large datasets.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. For example, you can append to a list with list.append(), but you cannot modify a tuple after it's created. Use lists when you need to modify the data, and tuples when you want to ensure the data remains constant.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations that can run concurrently, like web requests or file operations. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance for tasks like web scraping or API calls.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a hash table/dictionary?",
    "answer": "Hash table lookups have O(1) average time complexity, meaning they take constant time regardless of the size of the data structure. However, in the worst case (when many hash collisions occur), it can degrade to O(n). Python dictionaries are implemented as hash tables, which is why dictionary lookups are so fast.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's throwing an exception?",
    "answer": "Read the traceback from bottom to top to find where the error occurred, then use print statements or the debugger to inspect variable values. The built-in pdb module lets you set breakpoints with pdb.set_trace(), or use an IDE debugger to step through code line by line. Always check the exception message first as it often tells you exactly what went wrong.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but references to nested objects remain the same, while a deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested objects affect both copies, while deep copy is safer but uses more memory.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you implement a binary search algorithm?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half, comparing the target with the middle element. If the target is smaller, search the left half; if larger, search the right half. Continue until found or the search space is empty, achieving O(log n) time complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying them. They use the @ syntax and work by wrapping the original function with additional functionality. Common uses include logging, authentication, timing functions, and caching results.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' compares the values of two objects to see if they're equal, while 'is' checks if two variables refer to the exact same object in memory. Use '==' to compare content and 'is' to compare identity. For example, two lists with the same elements are == but not 'is' unless they're the same object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can you handle race conditions when using asyncio in Python?",
    "answer": "Use asyncio synchronization primitives like asyncio.Lock(), asyncio.Semaphore(), or asyncio.Event() to coordinate access to shared resources. Locks ensure only one coroutine can access critical sections at a time, while semaphores limit the number of concurrent operations. Always use 'async with' syntax when working with these primitives to ensure proper cleanup.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's a good way to handle errors in Python code?",
    "answer": "Use try/except blocks to catch specific exceptions rather than catching all exceptions with bare 'except'. Handle exceptions at the appropriate level where you can meaningfully respond to them, and use 'finally' blocks for cleanup code that must always run. Consider using logging instead of print statements for error information in production code.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and execution flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step-by-step, verify input data, and consider using an IDE with debugging features to set breakpoints and inspect variables in real-time.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that involve waiting. It's particularly useful when you need to handle multiple concurrent operations without blocking the main thread. However, avoid async/await for CPU-intensive tasks as it won't provide performance benefits and adds complexity unnecessarily.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to their hash table implementation. In the worst case (when there are many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Explain what this code does: result = [x**2 for x in range(10) if x % 2 == 0]",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using 'if x % 2 == 0', then squares each even number with 'x**2'. The result will be [0, 4, 16, 36, 64], representing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are some Python best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small with single responsibilities. Write docstrings for functions and classes, handle exceptions appropriately, and use type hints for better code documentation. Additionally, avoid deep nesting, use list/dict comprehensions when they improve readability, and organize code into logical modules.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python code simultaneously, making multithreading ineffective for CPU-bound tasks in CPython. However, threads can still be beneficial for I/O-bound operations since the GIL is released during I/O waits. For CPU-intensive parallel processing, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks if two variables reference the same object in memory (identity), while '==' checks if the values are equal (equality). For example, two separate lists with identical contents will be equal (==) but not the same object (is). Use 'is' when checking for None or comparing with singleton objects, and use '==' for value comparisons.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do you implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. The time complexity is O(log n), making it much faster than linear search for large datasets. Here's the key: maintain left and right pointers and update them based on comparisons.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Explain the difference between deep copy and shallow copy in Python, and when each might cause issues.",
    "answer": "Shallow copy creates a new object but inserts references to objects found in the original, while deep copy creates a new object and recursively copies all nested objects. Shallow copy issues arise when modifying nested mutable objects affects the original, while deep copy can cause problems with circular references or when copying complex objects like database connections. Use copy.copy() for shallow and copy.deepcopy() for deep copying.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure your conditional statements and loops are working as expected. Consider using an IDE with debugging features for a more visual debugging experience.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like web requests, file operations, or database queries that involve waiting. It's particularly useful when you need to handle multiple operations concurrently without blocking the main thread. Avoid async/await for CPU-bound tasks, as it won't improve performance and may add unnecessary complexity. The key benefit is improved responsiveness and efficiency in applications that spend time waiting for external resources.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a hash table versus a binary search tree?",
    "answer": "Hash tables (dictionaries in Python) offer O(1) average-case lookup time, making them very fast for most operations. Binary search trees provide O(log n) lookup time in the best case when balanced, but can degrade to O(n) if unbalanced. Hash tables are generally preferred for simple key-value lookups, while BSTs are better when you need ordered data or range queries.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references that reference counting can't resolve. Issues can arise with memory leaks from circular references, performance hiccups during garbage collection cycles, or when working with large datasets where you need more control over memory management. You can use the gc module to monitor and tune garbage collection behavior.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and write docstrings for your functions and classes. Keep functions small and focused on a single responsibility, avoid deep nesting, and use list comprehensions judiciously. Always handle exceptions appropriately and use virtual environments to manage dependencies. Regular code reviews and automated testing also help maintain code quality.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await in Python?",
    "answer": "Wrap await calls in try-except blocks just like synchronous code, but be aware that exceptions in one coroutine won't automatically propagate to others. Use asyncio.gather() with return_exceptions=True to collect exceptions from multiple coroutines, or handle them individually. For background tasks, use asyncio.create_task() and check the result with task.exception() to avoid silent failures. Consider using asyncio.wait() with return_when parameter for more complex exception handling scenarios.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copies are faster and use less memory, but changes to nested mutable objects affect both copies. Deep copies are completely independent but slower and more memory-intensive.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a slow Python loop that processes a large dataset?",
    "answer": "First, profile your code to identify the actual bottleneck using tools like cProfile or line_profiler. Consider vectorizing operations with NumPy, using list comprehensions instead of explicit loops, or leveraging built-in functions like map() and filter(). For very large datasets, consider processing in chunks, using generators to save memory, or parallel processing with multiprocessing. Sometimes the solution is algorithmic - using better data structures or reducing the algorithm's time complexity.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why does my Python code work in the interpreter but fail when run as a script?",
    "answer": "This often happens due to differences in the current working directory, import paths, or how variables persist in the interactive interpreter. Check if your script assumes files are in a specific location relative to where it's run. Ensure all necessary imports are included in your script, as the interpreter might have modules already loaded. Use absolute paths or properly handle relative paths, and make sure your script doesn't rely on variables defined in previous interpreter sessions.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. For example, my_list = [1, 2, 3] can be modified with my_list.append(4), but my_tuple = (1, 2, 3) cannot be changed. Use lists when you need to modify data and tuples for fixed collections or as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify the exact line causing the error. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. You can add 'import pdb; pdb.set_trace()' before the problematic line to step through your code interactively. Consider using try-except blocks to handle expected exceptions gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when dealing with I/O-bound operations like network requests, file operations, or database queries that involve waiting. It allows other code to run while waiting for these operations to complete, improving performance in concurrent scenarios. Don't use it for CPU-bound tasks as it won't provide performance benefits. Always use 'await' with async functions and run them with asyncio.run() or within an async context.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookup in Python has an average time complexity of O(1) due to hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time. The constant-time access makes dictionaries ideal for caching and mapping operations.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions without suppressing important errors?",
    "answer": "Be specific with exception types rather than using bare 'except:' clauses, and only catch exceptions you can meaningfully handle. Always log exceptions with sufficient context for debugging, and re-raise them if needed using 'raise' without arguments. Use 'finally' blocks for cleanup code that must run regardless of success or failure. Consider using custom exception classes for application-specific errors to make error handling more precise.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10) (numbers 0-9), filters for even numbers using 'if x % 2 == 0', and squares each even number with 'x**2'. The result will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8 respectively.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a function that's running too slowly?",
    "answer": "First, profile your code using tools like cProfile or line_profiler to identify bottlenecks rather than guessing. Look for opportunities to reduce algorithm complexity, cache repeated calculations, or use built-in functions which are often implemented in C. Consider using appropriate data structures (sets for membership testing, deques for frequent insertions/deletions). For I/O-bound operations, async programming or threading might help, while CPU-bound tasks might benefit from multiprocessing.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks if two variables refer to the same object in memory (identity), while '==' checks if the values are equal (equality). For example, two separate lists with identical contents will be equal (==) but not identical (is). Use 'is' when comparing to None, True, or False, and '==' when comparing values. This distinction is important for understanding how Python handles object references and can prevent subtle bugs.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly implement error handling in async functions?",
    "answer": "Use try-except blocks around await statements to catch specific exceptions from async operations. Consider using asyncio.gather() with return_exceptions=True to handle multiple async operations gracefully. For timeout handling, use asyncio.wait_for() to prevent indefinite blocking. Always ensure that async context managers (async with) and async iterators are properly handled, and consider using asyncio.create_task() for fire-and-forget operations with proper exception handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a generator instead of a list in Python?",
    "answer": "Use generators when working with large datasets that don't fit in memory, or when you only need to iterate through data once. Generators are memory-efficient because they produce items on-demand rather than storing everything in memory. They're perfect for processing files line-by-line, infinite sequences, or expensive computations where you might not need all results. However, use lists when you need random access, multiple iterations, or built-in list methods.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. For example: my_list = [1, 2, 3] can be changed, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access an index that doesn't exist in a sequence. Use print statements or a debugger to check the length of your list/string and the index values you're using. Common causes include off-by-one errors in loops or accessing empty lists. Always ensure your index is less than len(sequence) and greater than or equal to 0.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python instead of regular functions?",
    "answer": "Use async/await when your code involves I/O operations like network requests, file operations, or database queries that can benefit from concurrency. Async functions allow other code to run while waiting for these operations to complete, improving performance for I/O-bound tasks. However, for CPU-intensive tasks, regular functions or threading/multiprocessing are better choices.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize this. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions without catching everything?",
    "answer": "Catch specific exceptions rather than using bare 'except:' clauses, which can hide bugs and make debugging difficult. Use multiple except blocks for different exception types, and always consider what you'll do when an exception occurs. For example: 'try: int(value) except ValueError: print(\"Invalid number\")' is better than 'except: pass' which silently ignores all errors.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between __str__ and __repr__ methods in Python classes?",
    "answer": "__str__ should return a human-readable string representation of the object, while __repr__ should return a string that ideally could recreate the object (or at least be unambiguous for debugging). __str__ is called by str() and print(), while __repr__ is called by repr() and in interactive sessions. If only one is defined, __repr__ serves as the fallback for both.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a recursive function that's causing a stack overflow?",
    "answer": "Consider using dynamic programming with memoization to cache results, converting to an iterative approach using a stack or queue, or implementing tail recursion optimization if your language supports it. You can also increase Python's recursion limit with sys.setrecursionlimit(), but it's better to redesign the algorithm. For example, iterative Fibonacci is much more efficient than naive recursive implementation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the proper way to use context managers with async/await?",
    "answer": "Use 'async with' for asynchronous context managers that implement __aenter__ and __aexit__ methods. This is essential for properly managing async resources like database connections or HTTP sessions. For example: 'async with aiohttp.ClientSession() as session:' ensures the session is properly closed even if an exception occurs, preventing resource leaks in async applications.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I choose between using a list comprehension or a regular for loop?",
    "answer": "Use list comprehensions for simple transformations or filtering that create a new list, as they're more readable and often faster. Use regular for loops when you need complex logic, multiple statements per iteration, or when you're not creating a new list. For example: [x*2 for x in numbers if x > 0] is clearer than a multi-line loop for this simple case.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects are shared between original and copy. Deep copy creates a completely independent copy including all nested objects. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy prevents this but uses more memory and time.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that might change, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming, allowing your program to handle other tasks while waiting for I/O operations like network requests or file reads. You define async functions with 'async def' and call them with 'await'. Use async/await when you have I/O-bound operations that can run concurrently, like making multiple API calls or handling web requests.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this error mean: 'IndexError: list index out of range'?",
    "answer": "This error occurs when you try to access a list element using an index that doesn't exist. For example, accessing index 5 in a list with only 3 elements (indices 0, 1, 2). To debug this, check the length of your list with len() and ensure your index is within the valid range (0 to len(list)-1).",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations in Python have average O(1) time complexity for insertion, deletion, and lookup due to hash table implementation. However, in worst-case scenarios (many hash collisions), these operations can degrade to O(n). Iterating through all items is O(n), where n is the number of key-value pairs.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try/except blocks to handle exceptions gracefully. Put risky code in the 'try' block and handle specific exceptions in 'except' blocks. Always catch specific exceptions rather than using bare 'except:' clauses, and consider using 'finally' for cleanup code that must run regardless of success or failure.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "The '==' operator checks if two objects have the same value (equality), while 'is' checks if two variables point to the same object in memory (identity). Use '==' to compare values and 'is' only when you need to check if two variables reference the exact same object, like when comparing to None or singleton objects.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple Python threads from executing bytecode simultaneously, making threading ineffective for CPU-bound tasks in CPython. However, threading is still useful for I/O-bound tasks since the GIL is released during I/O operations. For CPU-bound parallelism, use multiprocessing instead of threading, or consider alternative Python implementations like Jython or IronPython.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's a list comprehension and how do I use it?",
    "answer": "A list comprehension is a concise way to create lists using a single line of code. The syntax is [expression for item in iterable if condition]. For example, [x*2 for x in range(5)] creates [0, 2, 4, 6, 8]. List comprehensions are more readable and often faster than equivalent for loops for creating lists.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running slowly?",
    "answer": "Start by profiling your code using the cProfile module to identify bottlenecks: python -m cProfile your_script.py. Look for functions with high cumulative time or many calls. Use tools like line_profiler for line-by-line analysis, and consider optimizing algorithms, reducing redundant operations, or using more efficient data structures based on your findings.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy creates completely independent objects.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets [], while a tuple is immutable (cannot be changed) and uses parentheses (). Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or database records.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when you try to access an index that doesn't exist in a sequence. Check that your index is within the valid range (0 to len(sequence)-1 for positive indices). Use print statements or a debugger to examine the actual length of your data structure and the index values you're using.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like making HTTP requests, reading files, or database queries that would otherwise block your program. It allows your program to handle other tasks while waiting for these operations to complete. Don't use it for CPU-intensive tasks, as Python's asyncio is designed for concurrency, not parallelism.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Searching in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case (when there are many hash collisions), it can degrade to O(n), but this is extremely rare with Python's hash function. This makes dictionaries ideal for fast lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python without catching everything?",
    "answer": "Catch specific exceptions rather than using bare 'except:' clauses, which can hide bugs. Use multiple except blocks for different exception types, and always include the most specific exceptions first. For example, catch FileNotFoundError before the more general OSError. This makes your code more maintainable and helps you handle different error conditions appropriately.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this list comprehension do: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This list comprehension creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10) (0-9), filters for even numbers using 'if x % 2 == 0', and squares each even number with 'x**2'. The result would be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I avoid race conditions when using async/await with shared resources?",
    "answer": "Use asyncio.Lock() to create a mutex that ensures only one coroutine can access the shared resource at a time. Wrap the critical section with 'async with lock:' to acquire and automatically release the lock. For more complex scenarios, consider using asyncio.Semaphore() to limit concurrent access or asyncio.Queue() for producer-consumer patterns.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to the objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copying is faster but changes to nested mutable objects affect both copies.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's the basic structure: set left=0, right=len(arr)-1, then while left<=right, calculate mid=(left+right)//2 and adjust boundaries based on comparison.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 for consistent formatting, use descriptive variable and function names, keep functions small and focused on a single task, and add docstrings to explain what your code does. Avoid deep nesting, use list comprehensions judiciously, handle exceptions appropriately, and write unit tests. Also, use type hints for better code documentation and IDE support.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better when you need to modify data, and tuples are ideal for fixed data that won't change. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an unexpected error?",
    "answer": "Start by reading the error message carefully - it usually tells you the line number and error type. Use print statements to check variable values at different points, or use Python's built-in debugger with import pdb; pdb.set_trace(). You can also use IDE debugging tools to set breakpoints and step through your code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that would otherwise block execution. Async programming allows other code to run while waiting for these operations to complete. It's particularly useful for web scraping, API calls, or handling multiple concurrent connections in web applications.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a dictionary versus a list?",
    "answer": "Dictionary lookup is O(1) average case because it uses hash tables, while list search is O(n) because it must check each element sequentially. This means dictionaries are much faster for lookups when you have large amounts of data. However, dictionaries use more memory and don't maintain insertion order in Python versions before 3.7.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collector work and when might it cause issues?",
    "answer": "Python uses reference counting as its primary garbage collection method, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector for handling circular references. Issues can arise with circular references in older Python versions, memory leaks in C extensions, or performance hiccups during garbage collection cycles in memory-intensive applications.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying their code. They use the @decorator_name syntax above function definitions. Decorators work by taking a function as input and returning a modified version, commonly used for logging, timing, authentication, or caching functionality.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "The '==' operator checks if two objects have the same value, while 'is' checks if they're the exact same object in memory. For example, two lists with identical contents will be == but not 'is' unless they're the same list object. Use '==' for value comparison and 'is' for identity comparison, especially with None: if x is None.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions without hiding errors?",
    "answer": "Use specific exception types rather than bare 'except:' clauses, and only catch exceptions you can meaningfully handle. Log errors appropriately and re-raise exceptions when necessary using 'raise' without arguments to preserve the stack trace. Consider using finally blocks for cleanup code and avoid using exceptions for normal program flow control.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deepcopy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy prevents this but uses more memory and time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I optimize this code: for i in range(len(my_list)): print(my_list[i])?",
    "answer": "Replace it with 'for item in my_list: print(item)' for direct iteration, or 'for i, item in enumerate(my_list): print(item)' if you need the index. Direct iteration is more Pythonic, readable, and slightly faster since it avoids index lookups. This follows Python's principle of writing clear, concise code that expresses intent directly.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better when you need to modify data, while tuples are ideal for fixed collections like coordinates or database records. Tuples also have slightly better performance and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries that would otherwise block your program. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, making your program more efficient.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of common Python list operations?",
    "answer": "Accessing an element by index is O(1), appending to the end is O(1), but inserting at the beginning is O(n) because all elements must shift. Searching for a value is O(n) since it requires checking each element. Understanding these complexities helps you choose the right data structure - use deque for frequent insertions at both ends, or sets for fast lookups.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python program that's not working as expected?",
    "answer": "Start by adding print statements to see variable values at different points, or use Python's built-in debugger with 'import pdb; pdb.set_trace()'. Read error messages carefully - they often point to the exact line and problem. Use an IDE with debugging features to set breakpoints and step through code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python list comprehensions and why should I use them?",
    "answer": "List comprehensions provide a concise way to create lists using the syntax [expression for item in iterable if condition]. They're often faster and more readable than equivalent for loops. For example, [x**2 for x in range(10) if x % 2 == 0] creates a list of squares of even numbers. They're a Pythonic way to transform and filter data in one line.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "The '==' operator checks if two objects have the same value, while 'is' checks if they're the exact same object in memory. Use '==' for comparing values and 'is' for comparing with None or checking object identity. For example, two lists with identical contents will be == but not 'is' unless they're the same object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions rather than bare 'except:' clauses. Always catch the most specific exception first, then more general ones. Use 'finally' for cleanup code that must run regardless of exceptions, and 'else' for code that should only run if no exception occurred. This makes your code more robust and easier to debug.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested objects affect both copies, while deep copy is safer but slower.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a dictionary versus a list in Python?",
    "answer": "Use dictionaries when you need to associate keys with values and want fast lookups by key (O(1) average case). Use lists when you have ordered data accessed by numeric index or when you need to maintain insertion order with duplicates. Dictionaries are perfect for mappings like user profiles, while lists work well for sequences like transaction histories.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and follow best practices?",
    "answer": "Follow PEP 8 style guidelines: use meaningful variable names, keep functions small and focused, add docstrings to explain what functions do. Use type hints for better code documentation and IDE support. Avoid deep nesting by using early returns, and prefer explicit over implicit code. Regular code reviews and using tools like pylint or black can help maintain consistency.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing with no clear error message?",
    "answer": "Start by adding print statements or using the logging module to trace execution flow and variable values. Use try-except blocks to catch and display specific exceptions. For more advanced debugging, use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at problematic lines, or use an IDE debugger to set breakpoints and step through code.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await for I/O-bound operations like making HTTP requests, reading files, or database queries where you're waiting for external resources. It allows other code to run while waiting, improving performance in applications handling many concurrent operations. Don't use it for CPU-intensive tasks, as Python's async is designed for concurrency, not parallelism.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using `x % 2 == 0`, and squares each even number with `x**2`. The result will be [0, 4, 16, 36, 64], representing 0\u00b2, 2\u00b2, 4\u00b2, 6\u00b2, and 8\u00b2.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await?",
    "answer": "Use try-except blocks around await calls just like synchronous code, but be aware that exceptions in background tasks might be silently ignored. For multiple concurrent operations, use `asyncio.gather()` with `return_exceptions=True` to collect both results and exceptions. Always await coroutines properly, as unhandled exceptions in fire-and-forget coroutines can be lost.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using global variables in my Python code?",
    "answer": "Global variables make code harder to test, debug, and maintain because any function can modify them, creating unpredictable side effects. They also make functions less reusable since they depend on external state. Instead, pass data as function parameters and return values, or use classes to encapsulate related data and behavior.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `==` and `is` in Python?",
    "answer": "`==` compares the values of objects for equality, while `is` compares object identity (whether they're the same object in memory). Use `==` for comparing values and `is` only for comparing with singleton objects like None, True, or False. For example, `[1,2,3] == [1,2,3]` is True, but `[1,2,3] is [1,2,3]` is False because they're different list objects.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a Python function that's processing large datasets?",
    "answer": "Use built-in functions and libraries like NumPy for numerical operations, as they're implemented in C and much faster. Consider using generators or itertools for memory-efficient processing of large datasets. Profile your code with cProfile to identify bottlenecks, and consider using list comprehensions instead of loops. For CPU-bound tasks, explore multiprocessing or Cython for performance-critical sections.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between merge sort and quick sort algorithms?",
    "answer": "Merge sort has guaranteed O(n log n) time complexity and is stable (preserves order of equal elements) but uses O(n) extra space. Quick sort has average O(n log n) time but worst-case O(n\u00b2), uses O(log n) space, and is typically faster in practice due to better cache performance. Choose merge sort when you need predictable performance and stability, quick sort when average-case speed matters more.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to be modified, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "The async/await syntax is used for asynchronous programming in Python, allowing your program to handle other tasks while waiting for I/O operations. Use 'async def' to define coroutines and 'await' to call them within other async functions. It's most beneficial for I/O-bound operations like web requests, file operations, or database queries where you're waiting for external resources.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to their hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize collisions. This makes dictionaries extremely efficient for key-based lookups compared to lists which require O(n) time for searches.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python program that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify where the error occurred and what type of exception was raised. Use print statements or the built-in debugger (pdb) to examine variable values at different points. You can also wrap suspicious code in try-except blocks to handle exceptions gracefully and get more information about what went wrong.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables reference the exact same object in memory). Use '==' when comparing values and 'is' when checking if two variables point to the same object, commonly used with None, True, False, or when checking object identity.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might I need to worry about it?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references that reference counting can't resolve. You typically don't need to manage this manually, but be aware of circular references in complex data structures and consider using weak references when appropriate.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the best way to implement a binary search algorithm in Python?",
    "answer": "Binary search works by repeatedly dividing a sorted array in half and comparing the target with the middle element. Here's the key: maintain left and right pointers, calculate mid = (left + right) // 2, then adjust the search space based on whether target is greater or less than the middle element. The algorithm has O(log n) time complexity and requires the input to be sorted.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "When should I use a generator instead of a list comprehension?",
    "answer": "Use generators when working with large datasets or when you don't need all values at once, as they're memory-efficient and evaluate lazily. Generators are created with parentheses (x for x in range(1000)) while list comprehensions use brackets [x for x in range(1000)]. Choose generators for memory efficiency and lists when you need to access elements multiple times or use list methods.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently changing them. They use the @ symbol and work by taking a function as input and returning a modified version. Common use cases include logging, timing, authentication, and caching. The decorator pattern leverages Python's ability to treat functions as first-class objects.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but keeps references to the original nested objects, while a deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy is safer but slower for complex nested structures.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to grow or shrink, while tuples are ideal for fixed data like coordinates or database records. Tuples are also faster to access and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that would otherwise block your program. Async code allows other tasks to run while waiting for slow operations to complete, improving overall performance. However, avoid async for CPU-intensive tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's crashing without clear error messages?",
    "answer": "Start by adding print statements or using the logging module to trace execution flow and variable values. Use try-except blocks to catch and display specific exceptions. For more advanced debugging, use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at problematic lines, or use an IDE's debugging features with breakpoints.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python dictionaries?",
    "answer": "Dictionary operations have average O(1) time complexity for lookup, insertion, and deletion due to hash table implementation. However, in worst-case scenarios (many hash collisions), these operations can degrade to O(n). Iterating through all keys, values, or items is O(n) where n is the number of elements.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might I need to worry about it?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically freeing objects when their reference count reaches zero. It also has a cyclic garbage collector to handle circular references. You typically need to worry about it when dealing with large datasets, circular references, or when using C extensions that don't follow Python's reference counting rules.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables refer to the exact same object in memory). Use '==' for comparing values and 'is' only for comparing with None, True, False, or when you specifically need to check object identity.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await?",
    "answer": "Use try-except blocks around await statements just like synchronous code, but be aware that exceptions in concurrent tasks won't propagate automatically. When using asyncio.gather(), exceptions from any task will be raised, but with asyncio.create_task(), you must explicitly await or check the task to see exceptions. Consider using asyncio.as_completed() for better exception handling with multiple concurrent operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to find duplicates in a list?",
    "answer": "Use a set to track seen elements: iterate through the list once, adding elements to the set and collecting duplicates when an element is already present. This approach has O(n) time complexity and O(n) space complexity. Alternatively, for just checking if duplicates exist, compare len(list) with len(set(list)).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I use list comprehensions instead of regular for loops?",
    "answer": "List comprehensions are more concise, readable, and often faster than equivalent for loops because they're optimized at the C level. They clearly express the intent to create a new list from existing data. However, use regular loops for complex logic, multiple statements, or when readability would suffer from cramming too much into a comprehension.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a thread-safe singleton pattern in Python that works with async code?",
    "answer": "Use asyncio.Lock() for async contexts and combine it with the double-checked locking pattern. Store the instance as a class variable and use async class methods to ensure thread safety during instantiation. Alternatively, consider using a module-level instance or asyncio.Event() to coordinate initialization across multiple coroutines, as these approaches are often simpler and less error-prone.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and are defined with square brackets, while tuples are immutable (cannot be changed) and are defined with parentheses. Lists are typically used for collections of similar items that may change, while tuples are used for fixed collections or when you need to ensure data integrity. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at breakpoints, or use your IDE's debugging features. Check for common issues like incorrect indentation, variable scope problems, or logical errors in conditionals and loops.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is async/await in Python and when should I use it?",
    "answer": "Async/await enables asynchronous programming, allowing your program to handle other tasks while waiting for slow operations like network requests or file I/O. Use 'async def' to define asynchronous functions and 'await' to pause execution until the awaited operation completes. This is particularly useful for I/O-bound tasks, web scraping, or handling multiple concurrent requests without blocking the entire program.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, keep functions small and focused on a single task, and add docstrings to document your code. Write comments for complex logic, use type hints for better code clarity, handle exceptions appropriately, and organize code into modules and packages. Always prefer readability over cleverness.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python code simultaneously, meaning true parallelism isn't achieved with threads in CPU-bound tasks. However, threading is still useful for I/O-bound operations since threads can release the GIL during I/O waits. For CPU-bound parallel processing, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrent operations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of common operations on Python dictionaries?",
    "answer": "Dictionary operations like lookup, insertion, and deletion are O(1) on average due to hash table implementation, but can degrade to O(n) in worst-case scenarios with many hash collisions. Iterating through all key-value pairs is O(n) where n is the number of items. This makes dictionaries excellent for fast lookups and caching, but the performance can vary based on the hash function quality and load factor.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than bare 'except' clauses, and handle only exceptions you can meaningfully recover from. Use 'finally' for cleanup code that must run regardless of exceptions, and consider 'else' for code that should only run if no exceptions occurred. Always log or handle exceptions appropriately rather than silently ignoring them.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copies and copy.deepcopy() for deep copies. Shallow copies are faster but changes to nested mutable objects affect both copies, while deep copies are independent but use more memory and time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I optimize the performance of a Python function that processes large datasets?",
    "answer": "Profile your code first using cProfile to identify bottlenecks, then consider using NumPy for numerical operations, list comprehensions instead of loops, and built-in functions like map() and filter(). For very large datasets, consider using generators to reduce memory usage, pandas for data manipulation, or libraries like Numba for just-in-time compilation. Sometimes rewriting critical sections in C or using multiprocessing can provide significant speedups.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is a Python generator and why would I use one?",
    "answer": "A generator is a function that uses 'yield' instead of 'return' to produce a sequence of values lazily (on-demand). Generators are memory-efficient because they don't store all values in memory at once, making them ideal for processing large datasets or infinite sequences. They maintain their state between calls and can be iterated over just like lists, but are created using generator expressions or functions with yield statements.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be modified after creation) and uses square brackets, while a tuple is immutable (cannot be changed after creation) and uses parentheses. Lists are better for data that needs to change, while tuples are ideal for fixed collections like coordinates or database records. Tuples also have slightly better performance and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's not producing any output?",
    "answer": "Start by adding print statements at key points to verify your code is executing as expected. Check if your script has proper indentation, especially if using if statements or loops that might prevent execution. Use a debugger like pdb or your IDE's built-in debugger to step through the code line by line. Also verify that any functions you're calling actually have return statements or print statements inside them.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program involves I/O operations like network requests, file operations, or database queries that would otherwise block execution. It's particularly useful when you need to handle multiple concurrent operations without creating expensive threads. Async/await shines in scenarios like web scraping, API calls, or building web servers where you're waiting for external resources frequently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst-case scenario (when hash collisions occur frequently), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries extremely efficient for key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and follow best practices?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small with single responsibilities. Write docstrings for functions and classes, use type hints for better code documentation, and organize imports properly. Also avoid deep nesting by using early returns and guard clauses, and consider using list/dict comprehensions for simple transformations.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await asyncio.gather()` and `await asyncio.as_completed()`?",
    "answer": "`asyncio.gather()` waits for all coroutines to complete and returns results in the same order they were submitted, making it ideal when you need all results before proceeding. `asyncio.as_completed()` returns an iterator that yields coroutines as they complete, allowing you to process results immediately as they become available. Use `gather()` when order matters and you need all results, use `as_completed()` when you want to process results as soon as they're ready.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when should I worry about it?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically freeing objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles between objects. You typically don't need to worry about garbage collection in normal Python code, but be aware of it when creating circular references, using large data structures, or in long-running applications where memory leaks might accumulate.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to remove duplicates from a list while preserving order?",
    "answer": "The most efficient approach is to use a set for O(1) lookups while iterating through the list: `list(dict.fromkeys(original_list))` or manually with `seen = set(); result = [x for x in original_list if not (x in seen or seen.add(x))]`. Both methods are O(n) time complexity and preserve the original order. Avoid using nested loops or repeated `list.remove()` calls as they result in O(n\u00b2) performance.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why am I getting a 'RecursionError: maximum recursion depth exceeded' error?",
    "answer": "This error occurs when your recursive function calls itself too many times without reaching a base case, exceeding Python's default recursion limit (usually around 1000 calls). Check that your recursive function has a proper base case that will eventually be reached and that each recursive call moves closer to that base case. You can increase the limit with `sys.setrecursionlimit()`, but it's better to redesign using iteration or optimize your recursive logic.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in async functions and avoid silent failures?",
    "answer": "Wrap async operations in try-except blocks just like synchronous code, but be careful with `asyncio.create_task()` and `asyncio.gather()` as they can suppress exceptions. Always await tasks or use `task.result()` to retrieve exceptions, and consider using `asyncio.gather(return_exceptions=True)` to collect exceptions rather than letting them halt execution. Use proper logging instead of bare except clauses to avoid silent failures that are hard to debug.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to change, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that would otherwise block your program. Async code allows other tasks to run while waiting for these operations to complete, improving overall performance. However, avoid async/await for CPU-intensive tasks as it won't provide benefits and adds complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing a KeyError?",
    "answer": "A KeyError occurs when trying to access a dictionary key that doesn't exist. First, print the dictionary contents to verify the key exists and check for typos or case sensitivity. Use the .get() method with a default value or check if the key exists with 'if key in dict:' before accessing it. You can also use try/except blocks to handle missing keys gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of common Python data structure operations?",
    "answer": "Lists have O(1) for append and access by index, but O(n) for insertion/deletion in the middle. Dictionaries and sets have O(1) average case for lookup, insertion, and deletion due to hash tables. Tuples have O(1) for access but are immutable, so no modification operations. Understanding these complexities helps choose the right data structure for performance-critical applications.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use specific exception types rather than bare 'except:' clauses to avoid catching unexpected errors. Always clean up resources using 'finally' blocks or context managers (with statements). Keep try blocks minimal - only wrap the code that might raise the exception. Consider using 'else' clauses for code that should run only when no exception occurs.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables reference the same object in memory). Use '==' for comparing values and 'is' for comparing with None, True, False, or when you specifically need to check object identity. For example: 'x == y' checks if they're equal, 'x is None' checks if x references the None object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making threading ineffective for CPU-bound tasks in CPython. However, threading is still beneficial for I/O-bound operations since the GIL is released during I/O waits. For CPU-intensive parallel processing, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the best way to iterate over a dictionary in Python?",
    "answer": "Use dict.items() to iterate over key-value pairs, dict.keys() for just keys, or dict.values() for just values. For example: 'for key, value in my_dict.items():'. Avoid modifying the dictionary size during iteration as it can cause errors. If you need to modify while iterating, create a copy first or collect changes to apply afterward.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm efficiently?",
    "answer": "Binary search requires a sorted array and works by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. This gives O(log n) time complexity. Always check bounds and handle edge cases like empty arrays or elements not found.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work under the hood?",
    "answer": "Decorators are functions that modify or extend other functions without permanently changing their code. They work using Python's first-class function support - a decorator takes a function as input and returns a modified version. The @decorator syntax is syntactic sugar for func = decorator(func). Decorators are commonly used for logging, authentication, caching, and timing functionality.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is a mutable data structure that can be modified after creation, while a tuple is immutable and cannot be changed once created. Lists are defined with square brackets [] and tuples with parentheses (). Use lists when you need to modify the collection, and tuples when you want to ensure the data remains constant.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python for making HTTP requests?",
    "answer": "Use the aiohttp library with async/await to make non-blocking HTTP requests. Define an async function with 'async def', use 'await' before async operations like aiohttp.get(), and run the function with asyncio.run(). This allows multiple requests to be processed concurrently without blocking the main thread.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case scenario (when many hash collisions occur), it can degrade to O(n), but this is rare in practice. This makes dictionaries very efficient for key-based lookups.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an IndexError?",
    "answer": "An IndexError occurs when trying to access an index that doesn't exist in a sequence. Use print statements or a debugger to check the length of your list/string and the index values you're using. Add bounds checking with 'if index < len(sequence):' before accessing elements, or use try/except blocks to handle the exception gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: 'result = [x**2 for x in range(10) if x % 2 == 0]'?",
    "answer": "This is a list comprehension that creates a list of squared even numbers from 0 to 9. It iterates through range(10), filters for even numbers (x % 2 == 0), squares each even number (x**2), and returns the result [0, 4, 16, 36, 64]. List comprehensions are a concise way to create lists based on existing iterables with optional filtering.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use asyncio.gather() versus asyncio.create_task() in Python?",
    "answer": "Use asyncio.gather() when you want to run multiple coroutines concurrently and wait for all of them to complete, returning their results in order. Use asyncio.create_task() when you want more control over individual tasks, such as canceling them or handling exceptions separately. gather() is simpler for batch operations, while create_task() offers more flexibility for complex async workflows.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for function naming and documentation?",
    "answer": "Use descriptive, lowercase function names with underscores (snake_case) like 'calculate_total_price()'. Include docstrings that explain what the function does, its parameters, and return value. Keep functions small and focused on a single responsibility, and use type hints to make your code more readable and maintainable.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might it cause performance issues?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector for handling circular references. Performance issues can arise with large numbers of objects, deep circular references, or frequent allocation/deallocation patterns, which can be mitigated using object pools or manual memory management techniques.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator compares the values of two objects to see if they are equal, while 'is' compares object identity to see if they are the same object in memory. Use '==' for value comparison and 'is' for identity comparison, typically with None checks like 'if value is None:'. For small integers and strings, Python may reuse objects, making 'is' return True unexpectedly.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python and what's its time complexity?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half, comparing the target with the middle element. Implementation involves setting left and right pointers, calculating mid = (left + right) // 2, and adjusting pointers based on comparison. The time complexity is O(log n) because you eliminate half the remaining elements with each iteration, making it very efficient for large sorted datasets.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant. For example: my_list = [1, 2, 3] can be changed, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like file reading, database queries, or API calls that involve waiting. It allows your program to handle other tasks while waiting for slow operations to complete, improving overall performance. However, avoid async/await for CPU-intensive tasks as it won't provide benefits and may add unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to find where the error occurred. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. You can also wrap suspicious code in try-except blocks to handle specific exceptions gracefully. The traceback shows the exact line and type of error, which is your starting point for investigation.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without changing their code directly. They work by taking a function as input and returning a modified version of that function. Common examples include @property for creating getters/setters and @staticmethod for methods that don't need class instances. The @ syntax is syntactic sugar for calling the decorator function.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (when many hash collisions occur), it can degrade to O(n), but this is rare in practice. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I avoid blocking the event loop when using asyncio?",
    "answer": "Never use blocking operations like time.sleep(), requests.get(), or regular file I/O inside async functions. Instead, use their async equivalents like asyncio.sleep(), aiohttp for HTTP requests, and aiofiles for file operations. For CPU-intensive tasks, use asyncio.get_event_loop().run_in_executor() to run them in a separate thread or process pool.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What does this code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squared even numbers from 0 to 9. It iterates through range(10), filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in async Python code?",
    "answer": "Use try-except blocks around await statements to catch specific exceptions that might occur during async operations. For multiple async tasks, use asyncio.gather() with return_exceptions=True to handle exceptions without stopping other tasks. Consider using asyncio.wait() with return_when parameters for more complex exception handling scenarios. Always handle asyncio.CancelledError appropriately for clean task cancellation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy prevents this but uses more memory and time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using global variables in my Python functions?",
    "answer": "Global variables make code harder to test, debug, and understand because functions become dependent on external state. They can lead to unexpected side effects and make it difficult to reason about function behavior. Instead, pass values as parameters and return results explicitly, making your functions pure and predictable. This follows the principle of minimizing coupling between different parts of your code.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "async/await is used for asynchronous programming to handle I/O-bound operations without blocking the main thread. Define functions with 'async def' and use 'await' to pause execution until an asynchronous operation completes. Use it for tasks like web requests, file I/O, or database queries where you're waiting for external resources, but avoid it for CPU-intensive tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the best way to debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify the exact line and error type. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. For systematic debugging, add logging with the logging module and use try-except blocks to handle specific exceptions gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of searching in a hash table and why?",
    "answer": "Hash table search has O(1) average time complexity because hash functions directly compute the index where data should be stored, allowing direct access. However, in the worst case (when many collisions occur), it can degrade to O(n) if all elements hash to the same bucket. Good hash functions and proper load factor management maintain the O(1) performance.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Can you explain what this Python code does: [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result would be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small and focused on a single task. Write docstrings for functions and classes, handle exceptions appropriately, and use type hints for better code documentation. Also, avoid deep nesting and prefer explicit code over clever one-liners.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might you need to worry about it?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically deleting objects when their reference count reaches zero. It also has a cyclic garbage collector for handling circular references between objects. You typically only need to worry about it in memory-intensive applications, when dealing with circular references, or when using C extensions that don't follow Python's memory management.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'is' checks for identity (whether two variables point to the same object in memory), while '==' checks for equality (whether two objects have the same value). Use 'is' when comparing with None, True, or False, and use '==' when comparing values. For example, two lists with identical contents are equal (==) but not identical (is) unless they're the same object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When would you use a deque instead of a list in Python?",
    "answer": "Use collections.deque when you need efficient insertions and deletions at both ends of the sequence, as deque provides O(1) operations while lists have O(n) for insertions/deletions at the beginning. Deques are ideal for implementing queues, sliding window algorithms, or when you need to frequently add/remove items from both ends. However, lists are better for random access since deque has O(n) indexing.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you implement a custom iterator in Python and what's the difference between __iter__ and __next__?",
    "answer": "__iter__ returns the iterator object itself and is called when iteration begins, while __next__ returns the next item in the sequence and raises StopIteration when exhausted. A class needs both methods to be iterable: __iter__ makes it work with for loops and iter(), while __next__ defines the actual iteration logic. You can also use generators with yield as a simpler alternative to writing custom iterators.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is mutable (can be changed after creation) and uses square brackets, while a tuple is immutable (cannot be changed) and uses parentheses. Lists are good for collections that need to be modified, while tuples are better for data that should remain constant, like coordinates or database records.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify where the error occurred. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. You can also use try-except blocks to catch specific exceptions and handle them gracefully.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like making HTTP requests, reading files, or database queries that would otherwise block your program. Async programming allows other code to run while waiting for these operations to complete, improving overall performance for concurrent tasks.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare in practice with Python's optimized hash functions.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I make my Python code more readable and maintainable?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, write docstrings for functions and classes, and keep functions small and focused on a single task. Also, avoid deep nesting and use comments sparingly to explain why, not what, your code does.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'await' and 'asyncio.gather()' in Python?",
    "answer": "Using 'await' executes async functions sequentially, waiting for each to complete before moving to the next. 'asyncio.gather()' runs multiple async functions concurrently and waits for all to complete, which is more efficient when tasks are independent and can run in parallel.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. This gives O(log n) time complexity compared to linear search's O(n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why am I getting a 'list index out of range' error?",
    "answer": "This error occurs when you try to access a list element at an index that doesn't exist. Check that your index is within the valid range (0 to len(list)-1) and ensure your list isn't empty before accessing elements. Use len() to verify list size or try-except blocks to handle the exception.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize memory usage when working with large datasets in Python?",
    "answer": "Use generators instead of lists when processing data sequentially, utilize pandas for efficient data manipulation, and consider using numpy arrays for numerical data. Also, delete unnecessary variables with 'del', use slots in classes to reduce memory overhead, and consider memory mapping for very large files.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables point to the same object in memory). Use '==' for comparing values and 'is' for comparing with None or checking if two variables reference the exact same object.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to change, while tuples are ideal for data that should remain constant. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot be.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step by step, verify input data, and ensure your conditions and loops are working as expected.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like network requests, file operations, or database queries that can benefit from concurrent execution. It's particularly useful when you need to handle multiple operations simultaneously without blocking the main thread. Avoid async/await for CPU-intensive tasks, as it won't provide performance benefits and adds unnecessary complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. However, in the worst-case scenario (when many hash collisions occur), it can degrade to O(n). This makes dictionaries extremely efficient for key-based lookups compared to lists, which have O(n) search complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, write docstrings for functions and classes, and keep functions small and focused on a single task. Additionally, handle exceptions appropriately, use list comprehensions when they improve readability, and avoid deep nesting by using early returns or guard clauses.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work?",
    "answer": "Python uses reference counting as its primary garbage collection mechanism, automatically deleting objects when their reference count reaches zero. For circular references, Python employs a cyclic garbage collector that periodically identifies and cleans up unreachable objects. The garbage collector runs automatically but can be controlled using the 'gc' module for fine-tuning in performance-critical applications.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What does this code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a new list containing the squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers using 'if x % 2 == 0', and squares each even number with 'x**2'. The result will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await in Python?",
    "answer": "Wrap async operations in try-except blocks just like synchronous code, and use asyncio.gather() with return_exceptions=True to handle multiple async operations. For timeout handling, use asyncio.wait_for() to set time limits on async operations. Remember that exceptions in async functions are encapsulated in the returned coroutine and won't be raised until awaited.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between deep copy and shallow copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates a new object and recursively copies all nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copy is faster but changes to nested mutable objects affect both copies, while deep copy is independent but more memory-intensive.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a simple implementation: def binary_search(arr, target): left, right = 0, len(arr) - 1; while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1; return -1.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses (). Lists are better for collections that need to change, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like API calls, file reading, or database queries. Define functions with 'async def' and use 'await' before calling other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle many concurrent requests.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of different operations on Python data structures?",
    "answer": "Lists have O(1) for append and access by index, but O(n) for insertion/deletion at arbitrary positions. Dictionaries and sets have average O(1) for lookup, insertion, and deletion due to hash tables. Deques from collections module offer O(1) operations at both ends, making them ideal for queues and stacks.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python program that's throwing an exception?",
    "answer": "Use try/except blocks to catch specific exceptions and print helpful error messages. Add print statements or use the built-in debugger (pdb) to trace variable values. Check the traceback carefully - it shows exactly where the error occurred and the call stack leading to it.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value (calls the __eq__ method), while 'is' checks if two variables reference the exact same object in memory. Use '==' for comparing values and 'is' for comparing with None or when you specifically need identity comparison. For example, 'x == y' might be True while 'x is y' is False.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search requires a sorted array and repeatedly divides the search space in half. Compare the target with the middle element, then search either the left or right half based on the comparison. This gives O(log n) time complexity. Always ensure your array is sorted first, and handle edge cases like empty arrays.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python best practices for writing clean code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable names, and keep functions small and focused on a single task. Write docstrings for functions and classes, avoid deep nesting with guard clauses, and use list comprehensions for simple transformations. Always handle exceptions appropriately and avoid bare except clauses.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL ensures only one Python bytecode instruction executes at a time, which means CPU-bound multithreaded programs won't see performance improvements. However, I/O-bound programs benefit because the GIL is released during I/O operations. For CPU-intensive tasks, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's a Python generator and how do I create one?",
    "answer": "Generators are functions that yield values one at a time instead of returning all at once, making them memory-efficient for large datasets. Create them using 'yield' instead of 'return', or with generator expressions like (x*2 for x in range(10)). They're lazy-evaluated, meaning values are computed only when requested, which is perfect for processing large files or infinite sequences.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle race conditions when using asyncio in Python?",
    "answer": "Use asyncio.Lock() to protect shared resources, similar to threading locks but for async code. Alternatively, use asyncio.Queue for safe communication between coroutines, or asyncio.Semaphore to limit concurrent access to resources. Always await these synchronization primitives, and consider using asyncio.gather() or asyncio.as_completed() for coordinating multiple async operations safely.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to change, while tuples are better for fixed data like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Async/await is used for asynchronous programming to handle I/O-bound operations without blocking the main thread. You define functions with 'async def' and call them with 'await' inside other async functions. Use it for tasks like web requests, file I/O, or database operations where you're waiting for external resources. This allows other code to run while waiting for slow operations to complete.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the best way to debug a Python script that's crashing?",
    "answer": "Start by reading the error traceback from bottom to top to identify the exact line and error type. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. Check for common issues like undefined variables, incorrect data types, or index out of range errors. Using an IDE with debugging features can also help you step through code line by line.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "Explain how Python's GIL affects concurrent programming and how to work around it.",
    "answer": "The Global Interpreter Lock (GIL) prevents true parallel execution of Python threads for CPU-bound tasks, as only one thread can execute Python code at a time. For I/O-bound tasks, threading still works well since threads can release the GIL during I/O operations. For CPU-bound parallelism, use multiprocessing instead of threading, or consider async/await for I/O-bound concurrency. Libraries like NumPy can also release the GIL during computations.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the time complexity of common operations on Python lists and dictionaries?",
    "answer": "List operations: access by index O(1), append O(1), insert/delete at beginning O(n), search O(n). Dictionary operations: access, insert, delete by key are all O(1) average case, O(n) worst case. Understanding these complexities helps you choose the right data structure - use lists for ordered data with index access, dictionaries for fast key-based lookups.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, keep functions small and focused on one task, and include docstrings for documentation. Use type hints for better code clarity, handle exceptions appropriately, and avoid deep nesting by using early returns. Write unit tests and use virtual environments to manage dependencies.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might you need to manage memory manually?",
    "answer": "Python uses reference counting as the primary garbage collection method, automatically freeing objects when their reference count reaches zero. It also has a cyclic garbage collector to handle reference cycles. Manual memory management is rarely needed, but you might use weak references for caches, explicitly close files/connections, or use __slots__ for memory-critical applications. The gc module provides tools for monitoring and controlling garbage collection.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' operators in Python?",
    "answer": "'==' checks for value equality (whether two objects have the same content), while 'is' checks for identity (whether two variables reference the exact same object in memory). Use '==' to compare values and 'is' only for singleton objects like None, True, or False. For example, two lists with the same elements are equal (==) but not identical (is) unless they're the same object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "Explain the difference between shallow copy and deep copy, and when to use each.",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same, while deep copy creates completely independent copies of all nested objects. Use shallow copy (copy.copy()) when you need a new container but can share the contents, and deep copy (copy.deepcopy()) when you need complete independence between objects. Deep copy is more expensive but necessary when modifying nested structures shouldn't affect the original.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can you implement a custom iterator class in Python and what methods are required?",
    "answer": "A custom iterator must implement __iter__() (returns self) and __next__() methods. The __next__() method should return the next item and raise StopIteration when exhausted. You can also create iterables by implementing __iter__() that returns an iterator object. Using generators with yield is often simpler than creating full iterator classes, as Python handles the iterator protocol automatically.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly more memory efficient and can be used as dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like web requests, file operations, or database queries. Define functions with 'async def' and call them with 'await' inside other async functions. This allows your program to handle other tasks while waiting for slow operations to complete, improving performance in applications that make many I/O calls.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching in a Python dictionary?",
    "answer": "Dictionary lookups in Python have an average time complexity of O(1) due to hash table implementation. In the worst case (with many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's not working as expected?",
    "answer": "Start by adding print statements to trace variable values and program flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' at breakpoints. Check error messages carefully and use try/except blocks to handle exceptions gracefully. IDEs like VS Code or PyCharm offer visual debugging tools with breakpoints and variable inspection.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between '==' and 'is' in Python?",
    "answer": "'==' checks if two objects have the same value (equality), while 'is' checks if two variables refer to the exact same object in memory (identity). Use '==' for comparing values and 'is' for comparing with None or checking object identity. For example, two lists with same contents are equal (==) but not identical (is).",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's Global Interpreter Lock (GIL) affect multithreading?",
    "answer": "The GIL prevents multiple threads from executing Python bytecode simultaneously, making threading ineffective for CPU-bound tasks in Python. However, threading is still useful for I/O-bound tasks since the GIL is released during I/O operations. For CPU-intensive parallel processing, use multiprocessing instead of threading to bypass the GIL limitation.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a shallow copy and a deep copy in Python?",
    "answer": "A shallow copy creates a new object but inserts references to objects found in the original, while a deep copy creates completely independent copies of nested objects. Use copy.copy() for shallow copying and copy.deepcopy() for deep copying. Shallow copies share nested mutable objects, so changes to nested elements affect both copies.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I handle exceptions properly in Python?",
    "answer": "Use try/except blocks to catch specific exceptions, always specify the exception type rather than using bare 'except'. Include finally blocks for cleanup code that must run regardless of exceptions. Use 'else' clause for code that should run only if no exceptions occurred, and consider logging exceptions for debugging purposes.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying their code. They use the @ syntax and work by wrapping the original function. Common uses include logging, authentication, timing, and caching. Decorators follow the principle of separation of concerns and make code more modular and reusable.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a generator instead of a list in Python?",
    "answer": "Use generators when working with large datasets or infinite sequences to save memory, as they produce items on-demand rather than storing everything in memory. Generators are ideal for processing large files, mathematical sequences, or data pipelines. They're created with yield statements or generator expressions and can only be iterated once.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better when you need to modify data, while tuples are ideal for fixed data that won't change. For example: my_list = [1, 2, 3] can be modified, but my_tuple = (1, 2, 3) cannot.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an unexpected exception?",
    "answer": "Start by reading the full traceback from bottom to top to identify the exact line causing the error. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. You can also use try/except blocks to catch specific exceptions and handle them gracefully while logging useful information.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your program performs I/O operations like network requests, file operations, or database queries that involve waiting. Async programming allows other tasks to run while waiting for these operations to complete, improving performance for I/O-bound applications. However, it's not helpful for CPU-intensive tasks and adds complexity to your code.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Dictionary lookups in Python have O(1) average time complexity due to their hash table implementation. In the worst case (when there are many hash collisions), it can degrade to O(n), but this is rare with Python's hash function. This makes dictionaries excellent for fast key-based lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are some Python best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines for consistent formatting, use descriptive variable and function names, and keep functions small and focused on a single task. Write docstrings for functions and classes, handle exceptions appropriately, and avoid deep nesting by using early returns. Also use type hints for better code documentation and IDE support.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do you implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a simple implementation: def binary_search(arr, target): left, right = 0, len(arr) - 1; while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1; return -1.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this Python code do: result = [x**2 for x in range(10) if x % 2 == 0]?",
    "answer": "This is a list comprehension that creates a list of squares of even numbers from 0 to 9. It iterates through range(10), filters for even numbers (x % 2 == 0), and squares each even number (x**2). The result will be [0, 4, 16, 36, 64], which are the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do you properly handle exceptions when using async/await with multiple concurrent operations?",
    "answer": "Use asyncio.gather() with return_exceptions=True to collect results and exceptions from multiple async operations, or wrap individual tasks in try/except blocks. You can also use asyncio.as_completed() to handle tasks as they finish and process exceptions individually. For critical applications, consider using asyncio.wait() with different return conditions to have fine-grained control over exception handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between __str__ and __repr__ methods in Python classes?",
    "answer": "__str__ is intended to provide a human-readable string representation of an object, typically for end users. __repr__ should provide an unambiguous string representation that ideally could recreate the object, mainly for developers and debugging. If only one is defined, Python will use __repr__ as a fallback for __str__, but not vice versa.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "How do you implement a thread-safe singleton pattern in Python?",
    "answer": "Use a double-checked locking pattern with threading.Lock() to ensure only one instance is created even in multithreaded environments. Alternatively, use the __new__ method with a class-level lock, or leverage Python's module system since modules are singletons by default. The threading.Lock() approach: class Singleton: _instance = None; _lock = threading.Lock(); def __new__(cls): if not cls._instance: with cls._lock: if not cls._instance: cls._instance = super().__new__(cls); return cls._instance.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to be modified, while tuples are ideal for data that should remain constant, like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's running but not producing the expected output?",
    "answer": "Start by adding print statements at key points to trace variable values and execution flow. Use Python's built-in debugger (pdb) by adding 'import pdb; pdb.set_trace()' where you want to pause execution. Check your logic step-by-step, verify input data, and consider using an IDE with debugging features to set breakpoints and inspect variables in real-time.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python and what are the benefits?",
    "answer": "Use async/await when your program performs I/O operations like file reading, database queries, or API calls that would otherwise block execution. The main benefits are improved performance through concurrent execution and better resource utilization. Instead of waiting idly for one operation to complete, your program can handle other tasks, making it especially valuable for web servers, data processing, or applications making multiple network requests.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst-case scenario (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize this. This makes dictionaries extremely efficient for lookups compared to lists, which have O(n) search complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I handle exceptions properly in Python without catching everything?",
    "answer": "Be specific about which exceptions you catch - avoid bare 'except:' clauses that catch all exceptions including system exits and keyboard interrupts. Catch the most specific exception types first, then more general ones, and always include proper error handling or logging. Use 'finally' blocks for cleanup code that must run regardless of success or failure, and consider re-raising exceptions after logging if they can't be properly handled at that level.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What does this code do: `result = [x**2 for x in range(10) if x % 2 == 0]`?",
    "answer": "This is a list comprehension that creates a list of squared even numbers from 0 to 9. It iterates through numbers 0-9, filters for even numbers (x % 2 == 0), and squares each even number (x**2). The resulting list will be [0, 4, 16, 36, 64], representing the squares of 0, 2, 4, 6, and 8.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly implement the Singleton pattern in Python?",
    "answer": "The most Pythonic way is using a decorator or metaclass, but a simple approach is overriding __new__: create a class variable to store the instance and return it if it exists. However, consider if you really need Singleton - often a module-level variable or dependency injection is more appropriate. Be aware that Singleton can make testing difficult and may not work as expected with threading without proper locking mechanisms.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between `await asyncio.gather()` and `await asyncio.wait()`?",
    "answer": "asyncio.gather() runs coroutines concurrently and returns results in the same order as input, raising an exception if any coroutine fails. asyncio.wait() provides more control, returning two sets (done and pending) and allows you to specify when to return (first completed, first exception, or all completed). Use gather() for simple concurrent execution where you need all results, and wait() when you need fine-grained control over completion handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using mutable objects as default function arguments?",
    "answer": "Mutable default arguments are created only once when the function is defined, not each time it's called, leading to unexpected behavior when the object is modified. For example, using `def func(lst=[]):` means all calls share the same list object. Instead, use `def func(lst=None): if lst is None: lst = []` to create a new object for each call. This is a common Python gotcha that can cause hard-to-debug issues.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collection work and when might I need to worry about it?",
    "answer": "Python uses reference counting as the primary mechanism, automatically deleting objects when their reference count reaches zero, plus a cyclic garbage collector for circular references. Most of the time you don't need to worry about it, but be aware when creating circular references, using weak references, or in memory-intensive applications. You might need manual intervention when working with large datasets, C extensions, or when profiling shows memory leaks from uncollected cycles.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "A list is a mutable data structure that can be modified after creation, while a tuple is immutable and cannot be changed once created. Lists are defined with square brackets [] and tuples with parentheses (). Use lists when you need to modify the data, and tuples when you want to ensure the data remains constant or when you need a hashable type for dictionary keys.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback carefully - it shows the exact line where the error occurred and the error type. Use print statements or the built-in debugger (pdb) to inspect variable values at different points. For systematic debugging, use an IDE with debugging capabilities or add logging statements to track the program's execution flow.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when you have I/O-bound operations like file reads, network requests, or database queries that would otherwise block your program. Async programming allows other code to run while waiting for these operations to complete, improving performance in applications that handle many concurrent operations. Don't use it for CPU-bound tasks as it won't provide performance benefits.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to its hash table implementation. In the worst case scenario (when there are many hash collisions), it can degrade to O(n), but this is rare in practice. This makes dictionaries extremely efficient for lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions in Python?",
    "answer": "Use try-except blocks to catch specific exceptions rather than using bare except clauses. Always catch the most specific exception types first, then more general ones. Use finally blocks for cleanup code that must run regardless of whether an exception occurs, and consider using else blocks for code that should only run when no exceptions are raised.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What is the difference between '==' and 'is' operators in Python?",
    "answer": "The '==' operator compares the values of two objects for equality, while 'is' checks if two variables reference the exact same object in memory. Use '==' when you want to compare content/values, and 'is' when you need to check object identity. A common use case for 'is' is checking for None: 'if x is None:'.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I make my async function handle multiple concurrent operations efficiently?",
    "answer": "Use asyncio.gather() to run multiple coroutines concurrently and wait for all to complete, or asyncio.as_completed() to process results as they become available. For better control, use asyncio.create_task() to schedule coroutines and asyncio.wait() with return conditions. Always use async context managers (async with) for resources like database connections in async code.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to remove duplicates from a list while preserving order?",
    "answer": "Use a combination of a set for tracking seen elements and a list comprehension: seen = set(); result = [x for x in original_list if not (x in seen or seen.add(x))]. Alternatively, for Python 3.7+, you can use dict.fromkeys(original_list) since dictionaries maintain insertion order. Both approaches are O(n) time complexity.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I implement a proper singleton pattern in Python?",
    "answer": "The most Pythonic way is to use a module (since modules are singletons by default) or implement __new__ method to control instance creation. You can also use a decorator or metaclass approach. However, consider if you really need a singleton - often dependency injection or simply using module-level variables is more appropriate and testable.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What are some Python coding best practices for writing clean, maintainable code?",
    "answer": "Follow PEP 8 style guidelines, use descriptive variable and function names, keep functions small and focused on a single responsibility, and add docstrings to document your code. Use type hints for better code clarity, avoid deep nesting with early returns, and write unit tests. Also, prefer explicit over implicit code and handle exceptions appropriately.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be modified after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for collections that need to change, like adding or removing items, while tuples are ideal for fixed data like coordinates or database records. Tuples are also slightly more memory-efficient and can be used as dictionary keys since they're hashable.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "When should I use async/await in Python?",
    "answer": "Use async/await when your code involves I/O operations like network requests, file operations, or database queries that can benefit from concurrency. Async programming allows your program to handle other tasks while waiting for slow operations to complete, improving overall performance. It's particularly useful for web servers, API clients, and applications that need to handle multiple simultaneous operations efficiently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How do I debug a Python script that's throwing an exception?",
    "answer": "Start by reading the traceback from bottom to top to identify where the error occurred and what type of exception was raised. Use print statements or the built-in debugger (pdb) to inspect variable values at different points in your code. Consider using try-except blocks to catch specific exceptions and handle them gracefully, and use logging instead of print statements for better debugging in production code.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity difference between list.append() and list.insert(0)?",
    "answer": "list.append() has O(1) time complexity because it adds elements to the end of the list, while list.insert(0) has O(n) complexity because it must shift all existing elements one position to the right. If you frequently need to add elements to the beginning of a collection, consider using collections.deque which provides O(1) insertion at both ends. For large datasets, this performance difference can be significant.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "Why should I avoid using global variables in my Python functions?",
    "answer": "Global variables make code harder to debug, test, and maintain because functions become dependent on external state that can change unexpectedly. They can lead to naming conflicts and make it difficult to understand what a function does just by looking at it. Instead, pass data as function parameters and return values explicitly, which makes your code more predictable, reusable, and easier to test.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How does Python's garbage collector handle circular references?",
    "answer": "Python's garbage collector uses a cycle detection algorithm to identify and clean up circular references that the reference counting system alone cannot handle. It periodically scans objects that can participate in cycles (like lists, dicts, and custom objects) and determines which groups of objects are unreachable from the program. The gc module provides control over this process, though manual intervention is rarely needed in typical applications.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between await and asyncio.gather() when running multiple async functions?",
    "answer": "Using await runs async functions sequentially, waiting for each to complete before starting the next, while asyncio.gather() runs them concurrently and waits for all to finish. asyncio.gather() is more efficient when you have multiple independent async operations because it maximizes concurrency. Use await for sequential dependencies and gather() when operations can run in parallel and you need all results.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "When should I use a dictionary versus a list in Python?",
    "answer": "Use dictionaries when you need to associate keys with values and require fast lookups by key (O(1) average case), like storing user profiles or configuration settings. Use lists when you have ordered data and need to access elements by position, iterate in sequence, or maintain insertion order matters less than position. Dictionaries are ideal for mapping relationships while lists are better for sequences and collections where order by index is important.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How can I optimize a Python function that's running too slowly?",
    "answer": "First, profile your code using tools like cProfile or line_profiler to identify bottlenecks rather than guessing. Common optimizations include using built-in functions and libraries (they're usually faster than custom implementations), choosing appropriate data structures (sets for membership testing, deques for frequent insertions), and avoiding repeated calculations by caching results. Consider using list comprehensions instead of loops and moving computation-heavy code to libraries like NumPy when applicable.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are the key differences between depth-first search (DFS) and breadth-first search (BFS) algorithms?",
    "answer": "DFS explores as far as possible along each branch before backtracking, using a stack (or recursion), while BFS explores all neighbors at the current depth before moving to the next level, using a queue. DFS uses less memory but may not find the shortest path, making it good for detecting cycles or exploring all possibilities. BFS guarantees the shortest path in unweighted graphs but uses more memory, making it ideal for finding minimum steps or levels in tree-like structures.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the difference between a list and a tuple in Python?",
    "answer": "Lists are mutable (can be changed after creation) and use square brackets, while tuples are immutable (cannot be changed) and use parentheses. Lists are better for data that needs to change, while tuples are ideal for fixed collections like coordinates or database records. Tuples are also slightly faster and can be used as dictionary keys, unlike lists.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I use async/await in Python and when should I use it?",
    "answer": "Use async/await for I/O-bound operations like file reading, database queries, or API calls. Define functions with 'async def' and call them with 'await' inside other async functions. This allows other code to run while waiting for slow operations to complete, improving performance in applications that handle multiple tasks concurrently.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What's the time complexity of searching for an element in a Python dictionary?",
    "answer": "Searching for an element in a Python dictionary has an average time complexity of O(1) due to hash table implementation. In the worst case (rare hash collisions), it can degrade to O(n), but Python's hash function is designed to minimize this. This makes dictionaries extremely efficient for lookups compared to lists which have O(n) search time.",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "How can I debug a Python script that's not producing any output?",
    "answer": "Start by adding print statements at key points to trace execution flow, or use Python's built-in debugger with 'import pdb; pdb.set_trace()'. Check if your script has syntax errors by running it with 'python -m py_compile filename.py'. Also verify that your main code isn't inside a function without being called, and ensure any conditional statements are actually being executed.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "What's the difference between 'is' and '==' in Python?",
    "answer": "'==' compares the values of two objects to see if they're equal, while 'is' checks if two variables reference the exact same object in memory. Use '==' for value comparison and 'is' for identity comparison, typically with None, True, False, or when you specifically need to check object identity. For example, 'a == b' checks equality, but 'a is b' checks if they're the same object.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I implement a binary search algorithm in Python?",
    "answer": "Binary search works on sorted arrays by repeatedly dividing the search space in half. Compare the target with the middle element: if equal, return the index; if target is smaller, search the left half; if larger, search the right half. Here's a basic implementation: def binary_search(arr, target): left, right = 0, len(arr)-1; while left <= right: mid = (left+right)//2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid+1; else: right = mid-1; return -1. Time complexity is O(log n).",
    "difficulty": "intermediate",
    "domain": "coding"
  },
  {
    "question": "What are Python decorators and how do I create one?",
    "answer": "Decorators are functions that modify or extend the behavior of other functions without permanently modifying them. They use the @decorator_name syntax above function definitions. To create one: def my_decorator(func): def wrapper(*args, **kwargs): # code before; result = func(*args, **kwargs); # code after; return result; return wrapper. Then use @my_decorator above any function you want to decorate.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "Why should I use list comprehensions instead of regular for loops?",
    "answer": "List comprehensions are more concise, readable, and often faster than equivalent for loops for creating lists. They express the intent more clearly in a single line: [x*2 for x in range(10)] vs a multi-line loop. They're also more Pythonic and can include conditions: [x for x in data if x > 0]. However, use regular loops for complex logic or when you need multiple operations per iteration.",
    "difficulty": "beginner",
    "domain": "coding"
  },
  {
    "question": "How do I properly handle exceptions when using async/await with multiple coroutines?",
    "answer": "Use asyncio.gather() with return_exceptions=True to handle exceptions from multiple coroutines, or wrap individual awaits in try-except blocks. For fire-and-forget tasks, use asyncio.create_task() and add exception handlers with task.add_done_callback(). Always handle CancelledError separately as it's used for cleanup. Consider using asyncio.wait() with return_when parameter for more control over completion and exception handling.",
    "difficulty": "advanced",
    "domain": "coding"
  },
  {
    "question": "What's the most efficient way to remove duplicates from a list while preserving order?",
    "answer": "Use dict.fromkeys() for Python 3.7+: list(dict.fromkeys(original_list)). This preserves insertion order and is very efficient. For older Python versions, use a set to track seen items: seen = set(); result = [x for x in original_list if not (x in seen or seen.add(x))]. Both approaches are O(n) time complexity, much better than nested loops which would be O(n\u00b2).",
    "difficulty": "intermediate",
    "domain": "coding"
  }
]